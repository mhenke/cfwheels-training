I0: Up and Running

Part of the reason ColdFusion on Wheels became popular quickly is that it takes a lot of the hard work off your hands, and that's especially true in starting up a project. CFWheels practices the idea of "sensible defaults" and tries to, with one command, create a working application ready for your customization.

h3. Setting the Stage

First we need to make sure everything is setup and installed. See the "Preparation for CFWheels Projects":/resources/CFWheels-jumpstart/preparation/ page for instructions on setting up and verifying your ColdFusion, CFWheels, and add-ons.

With that done we need to create new project in Eclipse. Open Eclipse and...

* Click "Create a New Project"
** Project name: JSBlogger
** Location: Choose a folder where you want to save your project -- and remember it!
** Project type: CFWheels application
** Click OK
** Ruby Interpreter should be 1.8.6 or 1.8.7
** CFWheels Version should be 2.3.3 or greater
** Click @Preconfigure for selected database@ and select @MySQL@
** Click OK

Eclipse will then create a CFWheels application for you and automatically open the file @database.yml@. If you were connecting to an existing database you would enter the database configuration parameters here. Since we're using MySQL and starting from scratch, we can leave the defaults. CFWheels will automatically create our database for us.

Then go to the RUN menu in the menubar and click RUN. The first time you do this it'll display the Run/Debug Configurations window. The defaults are all fine, but I enable the @Run Browser@ checkbox near the bottom to automatically open the site in my default browser. You can UNCHECK the @Display settings before launching@ checkbox, if present, then hit RUN. 

You should then see the @server@ window open at the bottom of Eclipse with your Mongrel webserver starting up. Once it's started Eclipse will open your default browser. If it doesn't open for some reason, try loading the address "http://wheels.local/":http://wheels.local. You should see CFWheels' "Welcome Aboard" page. Click the "About your application's environment" link and it'll display the versions of all your installed components.

h3. Creating the Article Model

Our blog will be centered around "articles," so we'll need a table in the database to store all the articles and a model to allow our CFWheels app to work with that data. We'll use one of CFWheels' generators to create the required files. Switch to your terminal and enter the following:

<pre>
cd JSBlogger
ruby script/generate model Article
</pre>

We're running the @generate@ script, telling it to create a @model@, and naming that model @Article@. From that information, CFWheels creates the following files:

* @/app/models/article.rb@ : The file that will hold the model code
* @/test/unit/article_test.rb@ : A file to hold unit tests for @Article@
* @/test/fixtures/articles.yml@ : A fixtures file to assist with unit testing
* @/db/migrate/(some_time_stamp)_create_articles.rb@ : A database migration to create the @articles@ table

With those files in place we can start developing!

h3. Working with the Database

CFWheels uses migration files to perform modifications to the database. Almost any modification you can make to a DB can be done through a migration. The killer feature about CFWheels migrations is that they're generally database agnostic. When developing applications I usually use MySQL as we are in this tutorial, but when I deploy to my server it is running PostgreSQL. Many others choose MySQL. It doesn't matter -- the same migrations will work on all of them!  This is an example of how CFWheels takes some of the painful work off your hands. You write your migrations once, then run them against almost any database.

What is a migration?  Let's open @/db/migrate/(some_time_stamp)_create_articles.rb@ and take a look. First you'll notice that the filename begins with a mish-mash of numbers which is a timestamp of when the migration was created. Migrations need to be ordered, so the timestamp serves to keep them in chronologic order. Inside the file, you'll see two methods: @self.up@ and @self.down@.

Migrations are meant to be _symmetric_. Whatever a migration changes inside the @self.up@ method should be _undone_ with the @self.down@ method. Frequently in development you'll think you want the database to look one way, then realize you need something different. You can create a migration to make your changes to the DB, start building, and then revert as necessary.

Inside the @self.up@ method you'll see the generator has placed a call to the @create_table@ method, passed the symbol @articles@ as a parameter, and created a block with the variable @t@ referencing the table that's created. We can tell @t@ what kind of columns we want in the @articles@ table. Well, what kind of fields does our Article need to have?  Since migrations make it easy to add or change columns later, we don't need to think of EVERYTHING right now, we just need a few to get us rolling. Here's a starter set:

* @title@ (a string)
* @body@ (a "text")

That's it! You might be wondering, what is the "text" type?  This is an example of relying on the CFWheels database adapters to make the right call. For some DBs, large text fields are stored as @varchar@, while other's like Postgres use a @text@ type. The database adapter will figure out the best choice for us depending on the configured database -- we don't have to worry about it.

So add these into your @self.up@ so it looks like this:

<pre>
  def self.up
    create_table :articles do |t|
      t.string :title
      t.text :body

      t.timestamps
    end
  end
</pre>

What is that @t.timestamps@ doing there?  The generator inserted that line. It will create two columns inside our table titled @created_at@ and @updated_at@. CFWheels will manage these columns for us, so when an article is created it's @created_at@ and @updated_at@ are automatically set. Each time we make a change to the article, the @updated_at@ will automatically be...uhhh...updated. Very handy.

Now our migration is done. You might wonder, what about the @self.down@?  Didn't I say migrations need to be symmetric?  If we added something to the @self.up@ it is _generally_ the case that we need to undo that same change in the @self.down@. However, when the migration is creating a table, the @self.down@ can just drop that table regardless of what columns are inside of it. That's what the generator has setup for us here, where it just says @drop_table :articles@.

Save that migration file, switch over to your terminal, and run this command:

<pre>
rake db:migrate
</pre>

This command starts the @rake@ program which is a ruby utility for running maintenance-like functions on your application (working with the DB, executing unit tests, deploying to a server, etc). We tell @rake@ to @db:migrate@ which means "look in your set of functions for the database (@db@) and run the @migrate@ function."  The @migrate@ action finds all migrations in the @/db/migrate/@ folder, looks at a special table in the DB to determine which migrations have and have not been run yet, then runs any migration that hasn't been run. 

In this case we had just one migration to run and it should print some output like this to your terminal:

<pre>
==  CreateArticles: migrating =================================================
-- create_table(:articles)
   -> 0.0012s
==  CreateArticles: migrated (0.0013s) ========================================
</pre>

It tells you that it is running the migration named @CreateArticles@. And the "migrated" line means that it completed without errors. As I said before, rake keeps track of which migrations have and have not been run. Try running @rake db:migrate@ again now, and see what happens.

We've now created the @articles@ table in the database and can start working on our @Article@ model.

h3. Working with a Model in the Console

Another awesome feature of working with CFWheels is the @console@. The @console@ is a command-line interface to your application. It allows you to access and work with just about any part of your application directly instead of going through the web interface. This can simplify your development process, and even once an app is in production the console makes it very easy to do bulk modifications, searches, and other data operations. So let's open the console now by going to your terminal and entering this:

<pre>
ruby script/console
</pre>

You'll then just get back a prompt of @>>@. You're now inside an @irb@ interpreter with full access to your application. Let's try some experiments...enter each of these commands one at a time and observe the results:

<pre>
puts Time.now
Article.all
Article.new
</pre>

The first line was just to demonstrate that we can do anything we previously did inside @irb@ now inside of our @console@. The second like referenced the @Article@ model and called the @all@ method which returns an array of all articles in the database -- so far an empty array. The third line created a new article object. You can see that this new object had attributes @id@, @title@, @body@, @created_at@, and @updated_at@.

All the information about the @Article@ model is in the file @/app/models/article.rb@, so let's open that now.

Not very impressive, right?  There are no attributes defined inside the model, so how does CFWheels know that an Article should have a @title@, a @body@, etc?  It queries the database, looks at the articles table, and assumes that whatever columns that table has should probably be the attributes accessible through the model. 

You created most of those in your migration file, but what about @id@?  Every table you create with a migration will automatically have an @id@ column which serves as the table's primary key. When you want to find a specific article, you'll look it up in the articles table by it's unique ID number. CFWheels and the database work together to make sure that these IDs are unique, usually using a special column type in the DB like "serial".

In your console, try entering @Article.all@ again. Do you see the blank article that we created with the @Article.new@ command?  No?  The console doesn't change values in the database (in most cases) until we explicitly call the @.save@ method on an object. Let's create a sample article and you'll see how it works. Enter each of the following lines one at a time:

<pre>
a = Article.new
a.title = "Sample Article Title"
a.body = "This is the text for my article, woo hoo!"
a.save
Article.all
</pre>

Now you'll see that the @Article.all@ command gave you back an array holding the one article we created and saved. Go ahead and *create 3 more sample articles*.

h3. Moving Towards a Web Interface - Setting up the Router

We've created a few articles through the console, but we really don't have a web application until we have a web interface. Let's get that started. We said that CFWheels uses an "MVC" architecture and we've worked with the Model, now we need a Controller and View. 

When a CFWheels server gets a request from a web browser it first goes to the _router_. The router decides what the request is trying to do, what resources it is trying to interact with. The router dissects a request based on the address it is requesting and other HTTP parameters (like the request type of GET or PUT). Let's open the router's configuration file, @/config/routes.rb@.

Inside this file you'll see a LOT of comments that show you different options for routing requests. Let's remove everything _except_ the first line (@ActionController...@) and the final @end@. Then, in between those two lines, add @map.resources :articles@ so your file looks like this:

<pre>
ActionController::Routing::Routes.draw do |map|
  map.resources :articles
end
</pre>

This line tells CFWheels to do a lot of work. It declares that we have a resource named @articles@ and the router should expect requests to follow the *RESTful* model of web interaction (REpresentational State Transfer). The details don't matter to you right now, but just know that when you make a request like @http://wheels.local/index.cfm/articles/@ the router will know you're looking for a listing of the articles or @http://wheels.local/index.cfm/articles/new@ means you're trying to create a new article.

Now that the router knows how to handle requests about articles, it needs a place to actually send those requests, the *Controller*.

h3. Creating the Articles Controller

We're going to use another CFWheels generator but your terminal has the console currently running. You have two options:

* Open a second terminal window (Cmd-T on OS X, open Command Prompt on Win) then CD to your project directory or...
* Close the console with the command @exit@

I like to have several terminal windows available to me when developing, so I'd always choose the first option.

In your terminal, enter this command:

<pre>
ruby script/generate controller articles
</pre>

The output shows that the generator created several files/folders for you:

* @app/views/articles@ : The directory to contain the controller's view templates
* @app/controllers/Articles.cfc@ : The controller file itself
* @test/functional/Articles.cfc_test.rb@ : The controller's unit tests file
* @app/helpers/articles_helper.rb@ : A helper file to assist with the views (discussed later)
* @test/unit/helpers/articles_helper_test.rb@ : The helper's unit test file

Let's open up the controller file, @/controllers/Articles.cfc@. You'll see that this is basically a blank class, beginning with the @class@ keyword and ending with the @end@ keyword. Any code we add to the controller must go _between_ these two lines, so I like to insert a bunch of blank lines between them so I have room work work and push that final @end@ farther down the page.

h3. Defining the Index Action

The first feature we want to add is an "index" page. This is what the app will send back when a user requests @http://wheels.local/index.cfm/articles/@ -- following the RESTful conventions, this should be a list of the articles. So when the router sees this request come in, it tries to call the @index@ action inside @Articles.cfc@.

Let's first try it out by entering @http://wheels.local/index.cfm/articles/@ into your web browser. You should get an error message that looks like this:

<pre>
Unknown action
No action responded to index. Actions:
</pre>

The router tried to call the @index@ action, but the articles controller doesn't have a method with that name. It then lists available actions, but there aren't any. This is because our controller is still blank. Let's add the following method inside the controller:

<pre>
  def index
    @articles = Article.all
  end  
</pre>

What is that "at" sign doing on the front of @articles@?  That marks this variable as an "instance level variable". We want the list of articles to be accessible from both the controller and the view that we're about to create. In order for it to be visible in both places it has to be an instance variable. If we had just named it @articles@, that local variable would only be available within the @index@ method of the controller.

Now refresh your browser. The error message changed, but you've still got an error, right?  

<pre>
Template is missing
Missing template articles/index.erb in view path app/views
</pre>

h3. Creating the Index View

The error message is pretty helpful here. It tells us that the app is looking for a (view) template in @/views/articles/@ but it can't find one named @index.erb@. CFWheels has *assumed* that our @index@ action in the controller should have a corresponding @index.erb@ view template in the views folder. We didn't have to put any code in the controller to tell it what view we wanted, CFWheels just figures it out.

Let's create that view template now. In the left pane of your Eclipse window, expand the @app@ folder so you can see @views@, then expand @views@. Right-click on the @articles@ folder, select @New@ then @File@ and, in the popup, name the file @index.cfm@.

Why did we choose @index.cfm@ instead of the @index.erb@ that the error message said it was looking for?  Putting the HTML in the name makes it clear that this view is for generating HTML. In later versions of our blog we might create an RSS feed which would just mean creating an XML view template like @index.xml.erb@. CFWheels is smart enough to pick the right one based on the browser's request, so when we just ask for @http://wheels.local/index.cfm/articles/@ it will find the @index.cfm@ and render that file.

Now you're looking at a blank file. Enter in this view template code which is a mix of HTML and what are called ERB tags:

<pre>
<h1>All Articles</h1>

<ul>
  <% @articles.each do |article| %>
    <li>
      <b><%= article.title %></b><br/>
      <%= article.body %>
    </li>  
  <% end %>
</ul>
</pre>

ERB is a templating language that allows us to mix Ruby into our HTML. There are only a few things to know about ERB:

* An ERB clause starts with @<%@ or @<%=@ and ends with @%>@
* If the clause started with @<%@, the result of the ruby code will be hidden
* If the clause started with @<%=@, the result of the ruby code will be output in place of the clause

Save the file and refresh your web browser. You should see a listing of the articles you created in the console. We've got the start of a web application!

h1. I1: Form-Based Workflow

We've created articles from the console, but that isn't a viable long-term solution. The users of our app will expect to add content through a web interface. In this iteration we'll create an HTML form to submit the article, then all the backend processing to get it into the database.

h3. Creating the NEW Action and View

Previously we setup the @map.resources :articles@ route in @routes.rb@, and that told CFWheels that we were going to follow the RESTful conventions for this model named Article. Following this convention, the URL for creating a new article would be @http://wheels.local/index.cfm/articles/new@. Enter that into your browser and see what comes up.

<pre>
Unknown action
No action responded to new. Actions: index
</pre>

This is an error message we've seen before. The router went looking for an action named @new@ inside the @Articles.cfc@ and didn't find it. For our convenience the message lists the actions that are available -- the only one being the @index@ we created in I0. 

So first let's create that action. Open @/controllers/Articles.cfc@ and add this method structure, making sure it's _inside_ the @ArticlesController@ class, but _outside_ the existing @index@ method:

<pre>
  def new
        
  end
</pre>

With that defined, refresh your browser and you should get this:

<pre>
Template is missing
Missing template articles/new.erb in view path app/views
</pre>

Again, an error message we saw in I0. Create a new file @/views/articles/new.cfm@ with these contents:

<pre>
<h1>Create a New Article</h1>
</pre>

Refresh your browser and you should just see the heading "Create a New Article".

h3. Writing a Form

It's not very impressive so far -- we need to add a form to the @new.cfm@ so the user can enter in the article title and body. Because we're following the RESTful conventions, CFWheels can take care of many of the details. Inside that @erb@ file, enter this code below your header:

<pre>
<% form_for(@article) do |f| %>
  <p>
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit 'Create' %>
  </p>
<% end %>
</pre>

What is all that?  Let's look at it piece by piece:

* @form_for@ is a CFWheels helper method which takes one parameter, in this case @article@ and a block with the form fields. The first line basically says "Create a form for the object named @article@, refer to the form by the name @f@ and add the following elements to the form..."
* The @f.label@ helper creates an HTML label for a field, this is good usability practice and will have some other benefits for us later
* The @f.text_field@ helper creates a single-line text box named @title@
* The @f.text_area@ helper creates a multi-line text box named @body@
* The @f.submit@ helper creates a button labeled "Create"

Refresh your browser and you'll see this:

<pre>
RuntimeError in Articles#new
Showing app/views/articles/new.cfm where line #3 raised:
Called id for nil, which would mistakenly be 4 -- if you really wanted the id of nil, use object_id

Extracted source (around line #3):
1: <h1>Create a New Article</h1>
2: 
3: <% form_for(@article) do |f| %>
4:   <%= f.error_messages %>
5: 
</pre>

What's it trying to tell us. In our @new.cfm@ on line #3 there was an error about "Called id for nil". As we learned in the Ruby in 100 minutes tutorial, @nil@ is Ruby's way of referring to nothingness. Somewhere in line #3 we're working with an object that doesn't exist.

And since there's only one object in line #3, it makes it pretty obvious -- the problem is that we started talking about a thing named @article@ without ever creating that thing. CFWheels uses some of the _reflection_ techniques that we talked about earlier in order to setup the form. Remember in the console when we called @Article.new@ to see what fields an Article has?  CFWheels wants to do the same thing, but we need to create the blank object for it.

Go into your @Articles.cfc@, and _inside_ the @new@ method, add this line:

<pre>
@article = Article.new
</pre>

Then refresh your browser and your form should come up. Enter in a title, some body text, and click CREATE.

h3. The CREATE Action

You're old friend pops up again...

<pre>
Unknown action
No action responded to create. Actions: index and new
</pre>

When we loaded the form we accessed the @new@ action, but when that form is submitted to the application, following the REST convention, it goes to a @create@ action. We need to create that action. Inside your @Articles.cfc@ add this method (again, _inside_ the ArticlesContoller class, but _outside_ the other methods):

<pre>
  def create
    @article = Article.new(params[article])
    @article.save!
    redirect_to articles_path
  end
</pre>

This method says...

* Create an object named @article@ and send in the parameter @params[article]@
* CFWheels makes the form data available inside the variable named @params@. If were to look at @params@ as a data structure, it'd be a hash with only one key -- @article@. The value of that pair is another hash with keys @title@ and @body@. The values for those keys are the data we entered into the text boxes on the form. So when @Article.new@ is called and the hash @params[article]@ is passed in, the @new@ method looks for the value with key @title@ and puts that into the Article's @title@ attribute. Then it looks for the value for key @body@ and puts that into the article's @body@ attribute.
* The line @article.save!@ saves the object to the database, just like we did in the console. We've added the exclamation mark here because we haven't implemented any error checking. The normal @save@ method will "fail silently" if there's a problem saving the article, but the @save!@ method will raise errors and basically freak out.
* Finally, the @redirect_to@ tells CFWheels that we don't want to render a view for this action. Once the previous steps are done, we want to bounce to the list of all articles. The router generates many friendly path-related variables for us just from the simple @map.resources :articles@ declaration. One of them is the @articles_path@ we use here -- it'll resolve to http://wheels.local/index.cfm/articles/.

Go back in your browser so you get to the form with the sample data you entered and click CREATE. You should then bounce to the full articles list with your new article added.

h3. Adding Navigation to the Index

Right now our article list is very plain and we end up typing in a bunch of URLs by hand. Let's add some links. Open your @/views/articles/index.cfm@ and...

* Add this code at the very bottom:<br/>@<%= linkTo "Create a New Article", new %>@<br/>which uses the CFWheels @linkTo@ helper, tells it we want a link with the text "Create a New Article" that points to the address @new@ (which the router handles for us)
* Find where, in the middle of the view, we output just the @article.title@. Change it so it says @linkTo article.title, article_path(article)@. This creates a link with the text of the articles title which points to a page where we'll show just that article.

Refresh your browser and you should now see a list of just the article titles that are linked somewhere and a link at the bottom to "Create a New Article". Test that this create link takes you to the new article form. Then go back to the article list and click one of the article titles.

h3. Creating the SHOW Action

Tired of this error message yet?  Go to your @Articles.cfc@ and add a method like this:

<pre>
def show

end
</pre>

Refresh the browser and you'll get the "Template is Missing" error. Let's pause here before creating the view template.

Look at the URL: @http://wheels.local/index.cfm/articles/1@. When we added the @linkTo@ in the index and pointed it to the @article_path@ for this @article@, the router created this URL. Following the RESTful convention, this URL goes to a SHOW method which would display the Article with ID number @1@. Your URL might have a different number depending on which article title you clicked in the index.

So what do we want to do when the user clicks an article title?  Find the article, then display a page with it's title and body. We'll use the number on the end of the URL to find the article in the database. The router will send us this number in the variable @params[id]@. Inside the @show@ method that we just created, add this line:

<pre>
@article = Article.find(params[id])
</pre>

Now create the file @/views/articles/show.cfm@ and add this code:

<pre>
<h2><%= @article.title %></h2>
<p><%= @article.body %></p>
<%= linkTo "<< Back to Articles List", articles_path %>
</pre>

Refresh your browser and your article should show up along with a link back to the index.

h3. But You Never Make Mistakes!

We can create articles and we can display them, but when we eventually deliver this to less perfect people than us, they're going to make mistakes. Right now there's no way to edit an article once it's been created. There's also no way to remove an article. Let's add those functions.

Look at your @index.cfm@ and change the whole @<li>@ segment so it looks like this:

<pre>
    <li>
      <b><%= linkTo article.title, article_path(article) %></b><br/>
      <i>Actions:
      <%= linkTo "edit", edit_article_path(article) %>,
      <%= linkTo "remove", article, :method => :delete,
                   :confirm => "Remove the article '#{article.title}'?" %>      
      </i>
    </li>
</pre>

The first link we added, for edit, is pretty similar to what we've done before -- creating a link with the text "edit" pointing to the address @edit_article_path@, which is defined by the router, and editing the thing named @article@.

The second one is a little more complex. Web browsers don't yet properly implement all the REST conventions, so CFWheels creates a hack for destroying objects. The details aren't too important. So this link will have the text "remove", will point to the @article@, and will use the HTTP method "delete". We've also added a @confirm@ parameter. If a link has a @confirm@, then CFWheels will generate some Javascript which will popup a box when the link is clicked that contains the text in the @confirm@. Here we're setting the message to check that the user wants to remove the article and including the article's title in the message.

Refresh your browser and you should see "edit" and "remove" links for each article. Click the EDIT link for your first article.

h3. Creating an Edit Action & View

The router is expecting to find an action in @Articles.cfc@ named @edit@, so let's add this:

<pre>
  def edit
    @article = Article.find(params[id])
  end
</pre>

All the @edit@ action is really going to do is find the article to be edited, then display the editing form. If you refresh after adding that @edit@ action you'll see the template missing error. Create a file @/views/articles/edit.cfm@ but *hold on before you type anything*. Below is what the edit form should look like:

<pre>
<h1>Edit an Article</h1>

<% form_for(@article) do|f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit 'Update' %>
  </p>
<% end %>
</pre>

In the Ruby and CFWheels communities there is a mantra of "Don't Repeat Yourself" -- but that's exactly what I've done here. This view is basically the same as the @new.cfm@ -- the only changes are the H1 and the name of the button. We can abstract this form into a single file called a _partial_, then reference this partial from both @new.cfm@ and @edit.cfm@.

Create a file @/views/articles/_form.cfm@ and, yes, it has to have the underscore at the beginning of the filename. Go into your @/views/articles/new.cfm@ and CUT all the text from and including the @form_for@ line all the way to it's @end@. The only thing left will be your H1 line. Then add the following code at the bottom of that view:

<pre>
<%= render :partial => 'form' %>
</pre>

Now go back to the @_form.cfm@ and paste the form code. Change the text on the @submit@ button to say "Save" so it makes sense both when creating a new article and editing and existing one.

Then look at your @edit.cfm@ file, write an H1 header saying "Edit an Article", then use the same code to render the partial named @form@.

Go back to your articles list and try creating a new article -- it should work just fine. Try editing an article and you should see the form with the existing article's data -- it works OK until you click SAVE.

The router is looking for an action named @update@. Just like the @new@ action sends it's form data to the @create@ action, the @edit@ action sends it's form data to the @update@ action. In fact, within our @Articles.cfc@, the @update@ method will look very similar to @create@

<pre>
  def update
    @article = Article.find(params[id])
    @article.update_attributes(params[article])
    @article.save!
    redirect_to article_path(@article)    
  end
</pre>

The only new bit here is the @update_attributes@ method. This method works very similar to when we called the @Article.new@ method and passed in the hash of form data. When we call @update_attributes@ on the @article@ object and pass in the data from the form, it changes the values in the object to match the values submitted with the form. Then we save the object to the database and redirect to the articles list.

Now try editing and saving some of your articles.

h3. Creating a Destroy Action

Next, click the REMOVE link for one article and hit OK. You can see that the router is expecting there to be a @destroy@ action. Go into @Articles.cfc@ and add a destroy method like this:

<pre>
  def destroy
    @article = Article.find(params[id])
    @article.destroy
    redirect_to articles_path
  end
</pre>

Here we're doing a @find@ based on @params[id]@ like we did in the @show@ action. We call that object's @destroy@ method, then redirect back to the articles list.

Try it out in your browser.

h3. Adding a Flash

It would be nice, though, if we gave the user some kind of status message about the operation that took place. When we create an article the message might say "Article 'the-article-title' was created", or "Article 'the-article-title' was removed" for the remove action. We can accomplish this with a special object called the @flash@.

CFWheels creates the object named @flash@, so we don't need to do anything to set it up. We can start by integrating it into our @index.cfm@ by adding this line at the very top:

<pre>
<div class="flash"><p><%= flash[message] %></p></div>
</pre>

This just outputs the value stored in the @flash@ object with the key @message@. If you refresh your articles list you won't see anything because we haven't stored a message in there yet. Look at @Articles.cfc@ and add this line right after the @save!@ line in your @create@ method:

<pre>
flash[message] = "Article '#{@article.title}' was created."
</pre>

Then go to your articles list, create another sample article, and when you click create you should see the flash message at the top of your view.

Here's something cool about how CFWheels handles the @flash@ -- hit your browser's REFRESH button while looking at the articles list. See how the flash disappears?  Once you display the message in a flash CFWheels clears it out. That's why it's perfect for status messages like this.

Similarly, add a flash message into your @destroy@ method and confirm that it shows up when an article is removed. Then add one to your @update@ method that'll display when an article is edited.

And, finally, you're done with I1!

h1. I2: Adding Comments

Most blogs allow the reader to interact with the content by posting comments. Let's add some simple comment functionality.

h3. Designing the Comment Model

First, we need to brainstorm what a comment _is_...what kinds of data does it have...

* It's attached to an article
* It has an author name
* It usually has an author email address
* It usually has an optional URL
* It has a body

With that understanding, let's create a Comment model. Switch over to your terminal and enter this line:

<pre>
ruby script/generate model Comment
</pre>

We've already gone through what files this generator creates, we'll be most interested in the migration file and the @comment.rb@.

h3. Setting up the Migration

Open the migration file that the generator created, @/db/migrate/some-timestamp_create_comments.rb@. Inside the @self.up@ you need to add one line for each of the pieces of data we just brainstormed. It'll start off with these...

<pre>
t.integer :article_id
t.string :author_name
</pre>

Then keep adding lines that create strings named @author_email@, @author_url@, and a text field named @body@.

Once that's complete, go to your terminal and run the migration with @rake db:migrate@.

h3. Relationships

The power of SQL databases is the ability to express relationships between elements of data. We can join together the information about an order with the information about a customer. Or in our case here, join together an article (in the articles table) with its comments (in the comments table). We do this by using foreign keys.

Foreign keys are a way of marking one-to-one and one-to-many relationships. An article might have zero, five, or one hundred comments. But a comment only belongs to one article. These objects have a one-to-many relationship -- one article connects to many comments.

Part of the big deal with CFWheels is that it makes working with these relationships very easy. When we created the migration for comments we started with an @integer@ field named @article_id@. The CFWheels convention is that, for a one-to-many relationship, the objects on the "many" end should have a foreign key referencing the "one" object. And that foreign key should be titled with the name of the "one" object, then an underscore, then "id". So in this case one article has many comments, so each comment has a field named @article_id@ which tracks which article they belong to. Similarly, a store's customer might have many orders, so each order would have a @customer_id@ specifying which customer they belong to.

Following this convention will get us a lot of functionality "for free."  Open your @/app/models/comment.rb@ and add the middle line so it looks like this:

<pre>
class Comment < ActiveRecord::Base
  belongs_to :article
end
</pre>

A comment relates to a single article, it "belongs to" an article. We then want to declare the other side of the relationship inside @/app/models/article.rb@ like this:

<pre>
class Article < ActiveRecord::Base
  has_many :comments
end
</pre>

How an article "has many" comments, and a comment "belongs to" an article. We have explained to CFWheels that these objects have a one-to-many relationship.

h3. Testing in the Console

Let's use the console to test how this relationship works in code. If you don't have a console open, go to your terminal and enter @ruby script/console@ from your project directory. If you have a console open already, enter the command @reload!@ to refresh any code changes.

Run the following commands one at a time and observe the output:

<pre>
a = Article.first
a.comments
Comment.new
a.comments.new
</pre>

When you called the @comments@ method on object @a@, it gave you back a blank array because that article doesn't have any comments. When you executed @Comment.new@ it gave you back a blank Comment object with those fields we defined in the migration. But, if you look closely, when you did @a.comments.new@ the comment object you got back wasn't quite blank -- it has the @article_id@ field already filled in with the ID number of article @a@.

Try creating a few comments for that article like this:

<pre>
c = a.comments.new
c.author_name = "Daffy Duck"
c.author_url = "http://daffyduck.com"
c.body = "I think this article is thhh-thhh-thupid!"
c.save
d = a.comments.create(:author_name => "Chewbacca", :body => "RAWR!")
</pre>

For the first comment, @c@, I used a series of commands like we've done before. For the second comment, @d@, I used the @create@ method. When you use @new@ it doesn't go to the database until you call @save@. With @create@ you usually pass in the attributes then the object is created, those attributes set, and the object saved to the database all in one step.

Now that you've created a few comments, try executing @a.comments@ again. Did your comments all show up?  When I did it, only one comment came back. The console tries to minimize the number of times it talks to the database, so sometimes if you ask it to do something it's already done, it'll get the information from the cache instead of really asking the database -- giving you the same answer it gave the first time. That can be annoying. To force it to clear the cache and lookup the accurate information, try this:

<pre>
reload!
a = Article.first
a.comments
</pre>

So you'll see that the article has comments -- great. Now we need to integrate them into the article display.

h3. Displaying Comments for an Article

We want to display any comments underneath their parent article. Because we've setup the relationships between those models, this is very easy. Open @/views/articles/show.cfm@ and add the following lines right before the link to the articles list:

<pre>
<h3>Comments</h3>
<%= render :partial => 'comment', :collection => @article.comments %>
</pre>

This says that we want to render a partial named "comment" and that we want to do it once for each element in the collection @article.comments@. We saw in the console that when we call the @.comments@ method on an article we'll get back an array of it's associated comment objects. So this render line will pass each element of that array one at a time into the partial named "comment". Now we need to create the file @/views/articles/_comment.cfm@ and add this code:

<pre>
<div class="comment">
  <h4>Comment by <%=h comment.author_name %></h4>
  <p><%=h comment.body %></p>
</div>
</pre>

With that in place, try clicking on your articles and find the one where you created the comments. Did they show up?  What happens when an article doesn't have any comments?

h3. Web-Based Comment Creation

Good start, but our users (hopefully) can't get into the console to create their comments. We'll need to create a web interface. We'll go through some of the same steps that we did when creating the web interface for creating articles.

Let's start with the form. The comment form should be embedded into the article's @show@ template. So let's add this code right above the "Back to Articles List" in the articles @show.cfm@

<pre>
<%= render :partial => 'comment_form' %>
</pre>

Obviously this is expecting a file @/views/articles/_comment_form.cfm@, so create that and add this content for now:

<pre>
<h3>Post a Comment</h3>
<p>(Comment form will go here)</p>
</pre>

Look at an article in your browser to make sure that partial is showing up. Then we can start figuring out the details of the form.

Ok, now look at your @Articles.cfc@ in the @new@ method. Remember how we had to create a blank Article object so CFWheels could figure out which fields an article has?  We need to do the same thing before we create a form for the comment. But when we view the article and display the comment form we're not running the article's @new@ method, we're running the @show@ method. So we'll need to create a blank Comment object inside that @show@ method like this:

<pre>
@comment = @article.comments.new
</pre>

This is just like we did it in the console. Now we can create a form inside our @_comment_form.cfm@ partial like this:

<pre>
<h3>Post a Comment</h3>

<% form_for @comment do |f| %>
  <%= f.hidden_field :article_id, :value => @article.id %>
  <p>
    <%= f.label :author_name %><br/>
    <%= f.text_field :author_name %>
  </p>
  <p>
    <%= f.label :author_email %><br/>
    <%= f.text_field :author_email %>
  </p>
  <p>
    <%= f.label :author_url %><br/>
    <%= f.text_field :author_url %>
  </p>
  <p>
    <%= f.label :body %><br/>
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit 'Submit' %>
  </p>
<% end %>
</pre>

The only new thing here is the hidden field helper. This hidden field will hold the ID of the article to help when creating the comment object.

Save then refresh in your web browser and...well...you'll get an error like this:

<pre>
NoMethodError in Articles#show
Showing app/views/articles/_comment_form.cfm where line #3 raised:
undefined method `comments_path' for #<ActionView::Base:0x10446e510>
</pre>

The @form_for@ helper is trying to build the form so that it submits to @comments_path@, but we haven't told the router anything about Comments yet. Open @/config/routes.rb@ and add this line at the top:

<pre>
map.resources :comments
</pre>

Then refresh your browser and your form should show up. Try filling out the comments form and click SUBMIT -- you'll get an error about @uninitialized constant CommentsController@.

h3. Creating a Comments Controller

Just like we needed an @Articles.cfc@ to manipulate our Articles, we'll need a @comments_controller.rb@. Switch over to your terminal to generate it with this line:

<pre>
ruby script/generate controller comments index create destroy
</pre>

What's up with those extra parameters?  Anything after the name of the controller (in this case "comments") will cause CFWheels to create stubs for methods with those names. Now open your @/app/controllers/comments_controller.rb@ and you'll see it has the three method stubs already.

The one we're interested in first is @create@. You can cheat by looking at the @create@ method in your @Articles.cfc@. For your @comments_controller.rb@, everything should be the same just replace article with comment. Then the redirect is a little different, use this:

<pre>
redirect_to article_path(@comment.article)
</pre>

Test out your form to create another comment now -- and it should work!

h3. Cleaning Up

We've got some decent comment functionality, but there are a few things we should add and tweak.

h4. Comments Count

Let's make it so where the view template has the "Comments" header it displays how many comments there are, like "Comments (3)". Open up your article's @show.cfm@ and change the comments header so it looks like this:

<pre>
<h3>Comments (<%= @article.comments.size %>)</h3>
</pre>

h4. Form Labels

The comments form looks a little silly with "Author Name" and "Author URL" and such. It should probably say "Your Name" and "Your URL (optional)", right?  To change the text that the label helper prints out, you just pass in the desired text as a second parameter, like this:

<pre>
<%= f.label :author_name, "Your Name"  %>
</pre>

Change your @_comment_form.cfm@ so it prints out "Your Name", "Your Email Address", "Your URL (optional)", and "Your Comment".

h4. Add Timestamp to the Comment Display

We should add something about when the comment was posted. CFWheels has a really neat helper named @distance_of_time_in_words@ which takes two dates and creates a text description of their difference like "32 minutes later", "3 months later", and so on. You can use it in your @_comment.cfm@ partial like this:

<pre>
<p>Posted <%= distance_of_time_in_words(comment.article.created_at, comment.created_at) %> later</p>
</pre>

With that, you're done with I2!

h1. I3: Tagging

In this iteration we'll add the ability to tag articles for organization and navigation.

First we need to think about what a tag is and how it'll relate to the Article model. If you're not familiar with tags, they're commonly used in blogs to assign the article to one or more categories. For instance, if I write an article about a feature in ColdFusion on Wheels, I might want it tagged with all of these categories: ruby, CFWheels, programming, features. That way if one of my readers is looking for more articles about one of those topics they can click on the tag and see a list of my articles with that tag.

h3. Understanding the Relationship

What is a tag?  We need to figure that out before we can create the model. First, a tag must have a relationship to an article so they can be connected. A single tag, like "ruby" for instance, should be able to relate to *many* articles. On the other side of the relationship, the article might have multiple tags (like "ruby", "CFWheels", and "programming" as above) - so it's also a *many* relationship. Articles and tags have a *many-to-many* relationship.

Many-to-many relationships are tricky because we're using an SQL database. If an Article "has many" tags, then we would put the foreign key @article_id@ inside the @tags@ table - so then a Tag would "belong to" an Article. But a tag can connect to *many* articles, not just one. We can't model this relationship with just the @articles@ and @tags@ tables.

When we start thinking about the database modeling, there are a few ways to achieve this setup. One way is to create a "join table" that just tracks which tags are connected to which articles. Traditionally this table would be named @articles_tags@ and CFWheels would express the relationships by saying that the Article model @has_and_belongs_to_many@ Tags, while the Tag model @has_and_belongs_to_many@ Articles.

Most of the time this isn't the best way to really model the relationship. The connection between the two models usually has value of its own, so we should promote it to a real model. For our purposes, we'll introduce a model named "Tagging" which is the connection between Articles and Tags. The relationships will setup like this:

* An Article @has_many@ Taggings
* A Tag @has_many@ Taggings
* A Tagging @belongs_to@ an Article and @belongs_to@ a Tag

h3. Making Models

With those relationships in mind, let's design the new models:

* Tag
** @name@ A string
* Tagging
** @tag_id@ Integer holding the foreign key of the related Tag
** @article_id@ Integer holding the foreign key of the related Article

Note that there are no changes necessary to Article because the foreign key is stored in the Tagging model. So now lets generate these models in your terminal:

<pre>
ruby script/generate model Tag name:string
ruby script/generate model Tagging tag_id:integer article_id:integer
rake db:migrate
</pre>

h3. Expressing Relationships

Now that our model files are generated we need to tell CFWheels about the relationships between them. For each of the files below, add these lines:

In @/app/models/article.rb@

<pre class=brush:ruby;">
  has_many :taggings
</pre>

In @/app/models/tag.rb@

<pre class=brush:ruby;">
  has_many :taggings
</pre>

Then in @/app/models/tagging.rb@

<pre class=brush:ruby;">
  belongs_to :article
  belongs_to :tag
</pre>

After CFWheels had been around for awhile, developers were finding this kind of relationship very common. In practical usage, if I had an object named @article@ and I wanted to find its Tags, I'd have to run code like this:

<pre class=brush:ruby;">
tags = article.taggings.collect{|tagging| tagging.tag}
</pre>

That's a pain for something that we need commonly. The solution was to augment the relationship with "through". We'll add a second relationship now to the Article and Tag classes:

In @/app/models/article.rb@

<pre class=brush:ruby;">
  has_many :taggings
  has_many :tags, :through => :taggings
</pre>

In @/app/models/tag.rb@

<pre class=brush:ruby;">
  has_many :taggings
  has_many :articles, :through => :taggings
</pre>

Now if we have an object like @article@ we can just ask for @article.tags@ or, conversely, if we have an object named @tag@ we can ask for @tag.articles@.

h3. An Interface for Tagging Articles

The first interface we're interested in is within the article itself. When I write an article, I want to have a text box where I can enter a list of zero or more tags separated by commas. When I save the article, my app should associate my article with the tags with those names, creating them if necessary.

Adding the text field will take place in the file @/views/articles/_form.cfm@. Add in a set of paragraph tags underneath the body fields like this:

<pre>
  <p>
    <%= f.label :tag_list %><br />
    <%= f.text_field :tag_list %>
  </p>
</pre>

With that added, try to create an new article in your browser and your should see this error:

<pre>
NoMethodError in Articles#new
Showing app/views/articles/_form.cfm where line #14 raised:
undefined method `tag_list' for #<Article:0x10499bab0>
</pre>

An Article doesn't have a thing named @tag_list@ -- we made it up. In order for the form to display, we need to add a method to the @article.rb@ file like this:

<pre>
  def tag_list
    return self.tags.join(", ")
  end
</pre>

Your form should now show up and there's a text box at the bottom named "Tag list". Enter content for another sample article and in the tag list enter @ruby, technology@. Click SAVE and you'll get an error like this:

<pre>
ActiveRecord::UnknownAttributeError in ArticlesController#create
unknown attribute: tag_list
</pre>

What is this all about?  Let's start by looking at the form data that was posted when we clicked SAVE. This data is in the production.log file which should be in the "Console" frame at the bottom of the Eclipse window. Look for the line that starts "Processing ArticlesController#create", here's what mine looks like:

<pre>
Processing ArticlesController#create (for 127.0.0.1) [POST]
  Parameters: {"article"=>{"body"=>"Yes, the samples continue!", "title"=>"My Sample", "tag_list"=>"ruby, technology"}, "commit"=>"Save", "authenticity_token"=>"xxi0A3tZtoCUDeoTASi6Xx39wpnHt1QW/6Z1jxCMOm8="}
</pre>

The field that's interesting there is the @"tag_list"=>"technology, ruby"@. Those are the tags as I typed them into the form. The error came up in the @create@ method, so let's peek at @/controllers/Articles.cfc@ in the @create@ method. See the first line that calls @Article.new(params[article])@?  This is the line that's causing the error as you could see in the middle of the stack trace.

Since the @create@ method passes all the parameters from the form into the @Article.new@ method, the tags are sent in as the string @"technology, ruby"@. The @new@ method will try to set the new Article's @tag_list@ equal to @"technology, ruby"@ but that method doesn't exist because there is no attribute named @tag_list@. 

There are several ways to solve this problem, but the simplest is to pretend like we have an attribute named @tag_list@. We can define the @tag_list=@ method inside @article.rb@ like this:

<pre>
  def tag_list=(tags_string)
    
  end
</pre>

Just leave it blank for now and try to resubmit your sample article with tags. It goes through!

h3. Not So Fast

Did it really work?  It's hard to tell. Let's jump into the console and have a look.

<pre>
a = Article.last
a.tags
</pre>

I bet the console reported that @a@ had @[]@ tags -- an empty list. So we didn't generate an error, but we didn't create any tags either.

We need to return to that @tag_list=@ method in @article.rb@ and do some more work. We're taking in a parameter, a string like @"tag1, tag2, tag3"@ and we need to associate the article with tags that have those names. The pseudo-code would look like this:

* Cut the parameter into a list of strings with leading and trailing whitespace removed (so @"tag1, tag2, tag3"@ would become @["tag1","tag2","tag3"]@
* For each of those strings...
** Look for a Tag object with that name. If there isn't one, create it.
** Create a Tagging object that connects this Article with that Tag

The first step is something that Ruby does very easily using the @.split@ method. Go into your console and try @"tag1, tag2, tag3".split@. By default it split on the space character, but that's not what we want. You can force split to work on any character by passing it in as a parameter, like this: @"tag1, tag2, tag3".split(",")@. 

Look closely at the output and you'll see that the second element is @" tag2"@ instead of @"tag2"@ -- it has a leading space. We don't want our tag system to end up with different tags because of some extra (non-meaningful) spaces, so we need to get rid of that. Ruby's String class has a @strip@ method that pulls off leading or trailing whitespace -- try it with @" my sample ".strip@. You'll see that the space in the center is preserved.

So to combine that with our @strip@, try this code:

<pre>
"tag1, tag2, tag3".split(",").collect{|s| s.strip.downcase}
</pre>

The @.split(",")@ will create the list with extra spaces as before, then the @.collect@ will take each element of that list and send it into the following block where the string is named @s@ and the @strip@ and @downcase@ methods are called on it. The @downcase@ method is to make sure that "ruby" and "Ruby" don't end up as different tags. This line should give you back @["tag1", "tag2", "tag3"]@.

Now, back inside our @tag_list=@ method, let's add this line:

<pre>
tag_names = tags_string.split(",").collect{|s| s.strip}
</pre>

So looking at our pseudo-code, the next step is to go through @each@ of those @tag_names@ and find or create a tag with that name. CFWheels has a built in method to do just that, like this:

<pre>
tag = Tag.find_or_create_by_name(tag_name)
</pre>

Once we find or create the @tag@, we need to create a @tagging@ which connects this article (here @self@) to the tag like this:

<pre>
self.taggings.build(:tag => tag)
</pre>

The @build@ method is a special creation method. It doesn't need an explicit save, CFWheels will wait to save the Tagging until the Article itself it saved. So, putting these pieces together, your @tag_list=@ method should look like this:

<pre>
  def tag_list=(tags_string)
    tag_names = tags_string.split(",").collect{|s| s.strip.downcase}
    tag_names.each do |tag_name|
      tag = Tag.find_or_create_by_name(tag_name)
      self.taggings.build(:tag => tag)
    end
  end
</pre>

h3. Testing in the Console

Go back to your console and try these commands:

<pre>
reload!
a = Article.new(:title => "A Sample Article for Tagging!",:body => "Great article goes here", :tag_list => "ruby, technology")
a.save
a.tags
</pre>

You should get back a list of the two tags. If you'd like to check the other side of the Article-Tagging-Tag relationship, try this:

<pre>
t = a.tags.first
t.articles
</pre>

And you'll see that this Tag is associated with just one Article.

h3. Adding Tags to our Display

According to our work in the console, articles can now have tags, but we haven't done anything to display them in the article pages. Let's start with @/views/articles/show.cfm@. Right below the line that displays the @article.title@, add this line:

<pre>
Tags: <%= tag_links(@article.tags) %><br />
</pre>

This line calls a helper named @tag_links@ and sends the @article.tags@ array as a parameter. We need to then create the @tag_links@ helper. Open up @/app/helpers/articles_helper.rb@ and add this method inside the @module@/@end@ keywords:

<pre>
def tag_links(tags)

end
</pre>

The desired outcome is a list of comma separated tags, where each one links to that tag's @show@ action -- the page where we'll list all the articles with that tag.

A helper method has to return a string which will get rendered into the HTML. In this case we'll use the @collect@ method to create a list of links, one for each Tag, where the link is created by the @linkTo@ helper. Then we'll @return@ back the @links@ connected by a comma and a space:

<pre>
  def tag_links(tags)
    links = tags.collect{|tag| linkTo tag.name, tag_path(tag)}
    return links.join(", ")
  end  
</pre>

Refresh your view and...BOOM:

<pre>
NoMethodError in Articles#show
Showing app/views/articles/index.cfm where line #6 raised:
undefined method `tag_path' for #<ActionView::Base:0x104aaa460>
</pre>

The @linkTo@ helper is trying to use @tag_path@ from the router, but the router doesn't know anything about our Tag object. We created a model, but we never created a controller or route. There's nothing to link to -- so let's generate that controller from your terminal:

<pre>
ruby script/generate controller tags index show
</pre>

Then we need to add it to our @/config/routes.rb@ like this:

<pre>
map.resources :tags
</pre>

Now refresh your view and you should see your linked tags showing up on the individual article pages.

Lastly, use similar code in @/views/articles/index.cfm@ to display the tags on the article listing page.

h3. Avoiding Repeated Tags

Try editing one of your article that already has some tags. Save it and look at your article list. You'll probably see that tags are getting repeated, which is obviously not what we want. 

When we wrote our @tag_list=@ method inside of @article.rb@, we were just thinking about it running when creating a new article. Thus we always built a new tagging for each tag in the list. But when we're editing, we might get the string "ruby, technology" into the method while the Article was already linked to the tags "ruby" and "technology" when it was created. As it is currently written, the method will just "retag" it with those tags, so we'll end up with a list like "ruby, technology, ruby, technology".

There are a few ways we could fix this -- the first thing I want to do is remove any repeated tags in the parameter list by using the Ruby method @uniq@

<pre>
tag_names = tags_string.split(",").collect{|s| s.strip.downcase}.uniq
</pre>

This is a good start but it doesn't solve everything. We'd still get repeated tags each time we edit an article.

If we edit an article and *remove* a tag from the list, this method as it stands now isn't going to do anything about it. Since we don't have anything valuable in the Tagging object besides the connection to the article and tag, they're disposible. We can just destroy all the taggings at the beginning of the method. Any tags that aren't in the @tags_string@ won't get re-linked. This will both avoid removed tags and prevent the "double tagging" behavior. Putting that all together, here's my final @tag_list=@ method:

<pre>
  def tag_list=(tags_string)
    self.taggings.destroy_all
    tag_names = tags_string.split(",").collect{|s| s.strip.downcase}.uniq
    tag_names.each do |tag_name|
      tag = Tag.find_or_create_by_name(tag_name)
      self.taggings.build(:tag => tag)
    end
  end
</pre>

It prevents duplicates and allows you to remove tags from the edit form. Test it out and make sure things are working!

h3. Listing Articles by Tag

The links for our tags are showing up, but if you click on them you'll get our old friend, the "No action responded to show. Actions:" error. Open up your @/app/controllers/tags_controller.rb@ and add a a @show@ method like this:

<pre>
  def show
    @tag = Tag.find(params[id])
  end  
</pre>

Then create a file @/app/views/tags/show.cfm@ like this:

<pre>
<h1>Articles Tagged with <%= @tag.name %></h1>

<ul>
  <% @tag.articles.each do |article| %>
    <li><%= linkTo article.title, article_path(article) %></li>
  <% end %>
</ul>
</pre>

Refresh your view and you should see a list of articles with that tag. Keep in mind that there might be some abnormalities from articles we tagged before doing our fixes to the @tag_list=@ method. For any article with issues, try going to it's @edit@ screen, saving it, and things should be fixed up. If you wanted to clear out all taggings you could do @Tagging.destroy_all@ from your console.

h3. Listing All Tags

We've built the @show@ action, but the reader should also be able to browse the tags available at @http://wheels.local/tags/@. I think you can do this on your own. Create an @index@ action in your @tags_controller.rb@ and an @index.cfm@ in the corresponding views folder. Look at your @Articles.cfc@ and Article @index.cfm@ if you need some clues.

If that's easy, try creating a @destroy@ method in your @tags_controller.rb@ and adding a destroy link to the tag list. If you do this, change the association in your @tag.rb@ so that it says @has_many :taggings, :dependent => :destroy@. That'll prevent orphaned Tagging objects from hanging around.

With that, a long Iteration 3 is complete!