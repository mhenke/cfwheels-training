<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h2 id="I0UpandRunning">I0: Up and Running</h2><p>Part of the reason ColdFusion on Wheels became popular quickly is it takes a lot of the hard work off your hands, and it's especially true in starting up a project. Wheels practices the idea of "sensible defaults" and tries to, with a couple simple actions, create a working application ready for your customization.</p><h3 id="SettingtheStage">Setting the Stage</h3><p>First we need to make sure everything is setup and installed. See the <a href="/resources/CFWheels-jumpstart/preparation/">Preparation for Wheels Projects</a> page for instructions on setting up and verifying your ColdFusion, Wheels, and add-ons.</p><p>With that done, we need to create new project in Eclipse. Open Eclipse and...</p><ul><li>File --&gt; New (Alt+Shift+N) --&gt; ColdFusion Project<ul><li>Project Name: JSBlogger</li><li>Uncheck Use Default Location in Project Location put "C:\JRun4\servers\cfwheels101\"</li><li>Click Finish</li></ul></li></ul><p>Eclipse will then create a ColdFusion project for you and automatically open the project.</p><p>Using ColdFusion Builder's Server view, we can add the our ColdFusion server. Open up the Servers view (Window - Show Views - Servers). In the Server view, click the add server icon. In the New ColdFusion Server Setup window set:</p><ul><li>Server Name: JSBloggers</li><li>Application Server: Jrun</li><li>Host Name: wheels.local<ul><li>Select Is Local</li></ul></li><li>WebServer Port: 80</li><li>Click Finish</li></ul><p>You should then see the <code>JSBloggers</code> server in the Servers view. If it isn't Running, please start it. Once it's started, try loading the address <a href="http://wheels.local/">http://wheels.local/</a>. You should see Wheels' "Congratulations" page. Scroll down and the Wheels debugging section displays the Wheels version, CFML Engine version along with other useful information.</p><p>We need to change the Wheels datasource convention. Wheels assumes our datasource connection is the folder name Wheels resides in but for our case it is not <code>cfwheels101</code> but <code>JSBloggers</code>. We could have easily named our ColdFusion server instance but I wanted to show how we can easily override a Wheels convention.</p><p>Press Ctrl+Shift+R while in Eclipse. This is the Open Resource window. I use this a lot when coding in Eclipse. Sometimes I highlight a file name in code and press Ctrl+Shift+R, other times I type in the file name like we will do next. Type in <code>settings.cfm</code>, and select <code>settings.cfm - /JSBloggers/config</code>. This will open that file for use and type in <code>&lt;cfset set(dataSourceName="JSBloggers") /&gt;</code> to tell Wheels to use this as are datasource. Also add in <code>&lt;cfset set(URLRewriting="Partial") /&gt;</code> to tell Wheels to use Partial for URL Rewriting. Then reload Wheels and you should see under DataSource, JSBloggers. To reload Wheels, you can add <code>?reload=true</code> to the url or click on the <code>Reload</code> link in the Wheels debug section.</p><p>Our blog will be centered around "articles," so we'll need a table in the database to store all the articles and a model to allow our Wheels app to work with that data.</p><h3 id="WorkingwiththeDatabase">Working with the Database</h3><p>Wheels can uses migration files to perform modifications to the database with the <strong>DBMigrate</strong> plugin. Almost any modification you can make to a DB can be done through a migration. The killer feature about Wheels migrations is they're generally database agnostic. When developing applications a person might usually use MySQL as we are in this tutorial, but when deploying to their production server it is running PostgreSQL. Many others choose Microsoft SQL Server. It doesn't matter - the same migrations will work on all of them! This is an example of how Wheels takes some of the painful work off your hands. You write your migrations once, then run them against almost any database.</p><h4 id="Whatisamigration">What is a migration?</h4><p>Migrations are a convenient way for you to alter your database in a structured and organized manner. Migrations are meant to be <em>symmetric</em>. Whatever a migration changes inside the <code>up</code> method should be <em>undone</em> with the <code>down</code> method. Frequently in development you'll think you want the database to look one way, then realize you need something different. You can create a migration to make your changes to the DB, start building, and then revert as necessary.</p><p>Let's generate a "Create table" migration for our articles. In the browser select, DBMigration link in the Wheels debugging section and open it in a new tab (This will make switching between plugins and our code easier). And complete the page like:</p><ul><li>Template: Create table</li><li>Migration prefix: Timestamp (e.g. 20110406075307)</li><li>Migration description: create articles table</li><li>Click create</li></ul><p>On the page, you should see text like <code>The migration 20110406195353_create_articles_table.cfc file was created</code> showing the create was successful. Two new sections appear also on the page: <strong>Migrate</strong> and <strong>Available migrations</strong>. Under <strong>Available migrations</strong> you should see something like <code>20110406195353 - create_articles_table (create articles table) - not migrated</code>. This is saying a migration script exists but hasn't been ran.</p><p>Let's open <code>/db/migrate/(some_time_stamp)__create_articles_table.cfc</code> and take a look. Press <code>ctrl-shift-r</code> again, and type <code>*create_</code> and select our newly created migration file. First please note the filename is our comment with underlines instead of spaces and a timestamp of when the migration was created. Migrations need to be ordered, so the timestamp serves to keep them in chronologic order. Inside the file, you'll see two methods: <code>up</code> and <code>down</code>.</p><p><pre lang="cfm"><br/><code><br/><cfcomponent extends="plugins.dbmigrate.Migration" hint="create articles table"><br/>  <cffunction name="up"><br/>   <cfscript><br/>   t = createTable('[tableName]');<br/>   t.timestamps();<br/>   t.create();<br/>   </cfscript><br/>  </cffunction><br/>  <cffunction name="down"><br/>   <cfscript><br/>   dropTable('[tableName]');<br/>   </cfscript><br/>  </cffunction><br/></cfcomponent><br/></code><br/></pre></p><p>Inside the <code>up</code> method you'll see the generator has placed a call to the <code>createTable</code> method, passed <code lang="tableName">@ as a parameter, and created a block with the variable @t</code> referencing the table that's created. Let's change <code lang="tableName">@ to @[articles]</code>. We can tell <code>t</code> what kind of columns we want in the <code>articles</code> table.</p><p>But first you might be wondering "What is <code>t.timestamps</code> doing there?". The generator inserted that line. It will create three columns inside our table titled <code>createdat</code> for when created, <code>updatedat</code> for last updated, and <code>deletedat</code> for soft deletes. Wheels will manage these columns for us, so when an article is created it's <code>createdat</code> and <code>updatedat</code> are automatically set. Each time we make a change to the article, the <code>updatedat</code> will automatically be...uhhh...updated. Very handy.</p><p>Well, what kind of fields does our Article need to have? Since migrations make it easy to add or change columns later, we don't need to think of EVERYTHING right now, we just need a few to get us rolling. Here's a starter set:</p><ul><li><code>title</code> (a string)</li><li><code>body</code> (a "text")</li></ul><p>So add these into your <code>up</code> so it looks like this:</p><p><pre lang="cfm"><br/><code><br/><cffunction name="up"><br/> <cfscript><br/> t = createTable('articles');<br/> t.string('title');<br/> t.text('body');<br/> t.timestamps();<br/> t.create();<br/> </cfscript><br/></cffunction><br/></code><br/></pre></p><p>That's it! You might be wondering, what is the "text" type? This is an example of relying on the Wheels database adapters to make the right call. For some DBs, large text fields are stored as <code>varchar</code>, while other's like Postgres use a <code>text</code> type. The database adapter will figure out the best choice for us depending on the configured database - we don't have to worry about it.</p><p>Now our <code>up</code> migration is done. You might wonder, what about the <code>down</code>? Didn't I say migrations need to be symmetric? If we added something to the <code>up</code> it is <em>generally</em> the case we need to undo the same change in the <code>down</code>. However, when the migration is creating a table, the <code>down</code> can just drop that table regardless of what columns are inside of it. That's what the generator has setup for us here, where it says <code>dropTable('[tableName]');</code> replace <code lang="tableName">@ with @articles</code>.</p><p><pre lang="cfm"><br/><code><br/><cffunction name="down"><br/> <cfscript><br/> dropTable('articles');<br/> </cfscript><br/></cffunction><br/></code><br/></pre></p><p>Save that migration cfc file, switch over to your browser, and click <code>go</code> under the <strong>Migrate</strong> section:</p><p>The <code>All non-migrated</code> option finds all migrations in the <code>/db/migrate/</code> folder, determines which migrations have and have not been run yet, then runs them. Pretty much it says "look in your set of cfcs for the database in <code>/db/migrate/</code> and run the migrations not yet ran."</p><p>In this case we had one migration to run and it should print some output like this to your browser under <strong>Migration Results</strong>:</p><p><pre lang="cfm"><br/>Migrating from 0 up to 20110406195353.</p><p>------- 20110406195353_create_articles_table --------------<br/>Created table articles<br/></pre></p><p>The migration page tells you the plugin ran the migration. As I said before, <strong>DBMigrate</strong> keeps track of which migrations <em>have</em> and <em>have not</em> been run. Try running <code>All non-migrated</code> again now, and see what happens.</p><p>We've now created the <code>articles</code> table in the database and can start working on our <code>Article</code> model. We can view the <code>SQL</code> under <code>/db/sql</code>.</p><h3 id="CreatingtheArticleModel">Creating the Article Model</h3><p>We'll use one of Wheels' plugins called Scaffolding to create the required file. Click the Scaffold link in the Wheels debugging section. Then type <code>article</code> for the Object name and select <strong>Model</strong> for Type. We'll leave the Template as default and click Generate. The page should refresh and "<strong>File 'models/Article.cfc' created.</strong>" should appear.</p><p>We used the <strong>Scaffold</strong> plugin, telling it to create a <code>model</code>, and naming that model <code>Article</code>. From that information, the plugin creates the following files:</p><ul><li><code>/models/Article.cfc</code> : The file will hold the model code</li></ul><p>With this file in place we can start developing!</p><h3 id="WorkingwithaModel">Working with a Model</h3><p>Another awesome feature of working with Wheels is the <code>ORM</code>. The <code>ORM</code> stands for Object-relational mapping. It allows you to map objects in your application to records in your database tables. This can simplify your development process and even once an app is in production the <code>ORM</code> makes it very easy to do modifications, searches, and other data operations. So let's create a <code>controller</code> to do some simple interactions with our <code>model</code>.</p><ul><li>File --&gt; New (Alt+Shift+N) --&gt; ColdFusion Component</li><li>Source Location: /JSBloggers/controllers<ul><li>By clicking Browse...</li></ul></li><li>Component Name: Examples</li><li>Extends: Controller</li><li>Click Finish</li></ul><p>Our new component opened automatically and we'll add some code in between the <code>cfcomponent</code> instructions. Let's try some experiments... To view our first experiment, we'll go to http://wheels.local/index.cfm/examples/one:http://wheels.local/index.cfm/examples/one.Enter each of these instructions and observe the results:</p><p><pre lang="cfm"><br/><code><br/><cffunction name="one"><br/> &lt;cfset time = now() /&gt;<br/> <cfdump var="#now()#" /><br/> &lt;cfset articles = model("article").findAll() /&gt;<br/> <cfdump var="#articles#" /><br/> &lt;cfset article = model("article").new() /&gt;<br/> <cfdump var="#article#" /><br/> <cfabort><br/></cffunction><br/></code><br/></pre></p><p>The first line was to demonstrate we can do anything in our <code>controller</code> we previously did during <code>CFML in 100 minutes</code>. The third line referenced the <code>Article</code> model and called the <code>findAll</code> method which returns a query of all articles in the database - so far an empty result. The fifth line created a new article object and returns it. The object is not saved to the database; it only exists in memory. Property names and values can be passed in either using named arguments or as a struct to the properties argument.</p><p>All the information about the <code>Article</code> model is in the file <code>/models/Article.cfc</code>, so let's open that now.</p><p>Not very impressive, right? There are no attributes defined inside the model, so how does Wheels know an Article should have a <code>title</code>, a <code>body</code>, etc? It queries the database, looks at the articles table, and assumes whatever columns the table has should probably be the attributes accessible through the model.</p><h4 id="LetslookattheArticlestable">Let's look at the Articles table</h4><p>You created most of the columns in your migration file, but what about the <code>id</code>? Every table you create with a migration will automatically have an <code>id</code> column which serves as the table's primary key. When you want to find a specific article, you'll look it up in the articles table by it's unique ID number. Wheels and the database work together to make sure that these IDs are unique, usually using a special column type in the DB like "serial".</p><p>Back to the <code>&lt;cfset article = model("article").new() /&gt;</code> instruction. The <code>new()</code> method doesn't change values in the database until we explicitly call the <code>save</code> method on an object in our example the <code>article</code> object didn't have th? attributes <code>id</code>, <code>title</code>, <code>body</code>, <code>createdat</code>, and <code>updatedat</code>. Let's create a sample article and you'll see how it to add these. Enter each of the following lines:</p><p><pre lang="cfm"><br/><code><br/><cffunction name="two"><br/> &lt;cfset a.title = "Sample Article Title" /&gt;<br/> &lt;cfset a.body = "This is the text for my article, woo hoo!" /&gt;<br/> &lt;cfset article = model("article").new(a) /&gt;<br/> &lt;cfset article.save() /&gt;<br/> &lt;cfset articles = model("article").findAll() /&gt;<br/> <cfdump var="#articles#" /><br/> <cfabort><br/></cffunction><br/></code><br/></pre></p><p>Now you'll see the <code>findAll()</code> command gave you back an query object holding the one article we created and saved. Go ahead and <strong>create 3 more sample articles</strong> in one request under a method called "moreSamples".</p><h3 id="MovingTowardsaWebInterfaceSettinguptheRouter">Moving Towards a Web Interface - Setting up the Router</h3><p>We've created a few articles through the Examples controller, but we really don't have a web application until we have a better web interface. Let's get that started. We said "Wheels uses an <strong>MVC</strong> architecture", and we've worked with the Model, now we need a Controller and View.</p><p>When a Wheels application gets a request from a web browser it first goes to the <em>router</em>. The router decides what the request is trying to do and what resources it is trying to interact with. The router dissects a request based on the address it is requesting. Let's open the router's configuration file, <code>/config/routes.cfm</code>.</p><p>Inside this file you'll see <code>&lt;cfset addRoute(name="home", pattern="", controller="wheels", action="wheels") /&gt;</code>. This is the default route and it directs to the Congratulations page, you saw when we first loaded our application. Let's replace it with:</p><p><pre lang="cfm"><br/><code><br/>&lt;cfset addRoute(name="home", pattern="", controller="Articles", action="index") /&gt;<br/></code><br/></pre></p><p>This line tells Wheels to do a lot of work. It declares that we have a resource named <code>home</code> and the router should expect requests to follow the <strong>RESTful</strong> model of web interaction (REpresentational State Transfer). The details don't matter to you right now, but just know that when you make a request like <code>http://wheels.local/</code> and the router will know you're looking for a <code>index action</code> of the <code>Articles controller</code>.</p><p>Now the router knows how to handle requests about articles, it needs a place to actually send those requests, the <code>Controller</code>.</p><h3 id="CreatingtheArticlesController">Creating the Articles Controller</h3><p>We're going to use the Scaffold plugin again. In your browser, enter this url to get to the Scaffold plugin: <code>http://wheels.local/index.cfm?controller=wheels&amp;action=wheels&amp;view=plugins&amp;name=scaffold</code></p><p>Type <strong>article</strong> for the Object name and select <strong>Controller</strong> for Type. We'll leave the Template as default and click Generate. The page should refresh and "<strong>File 'controllers/Articles.cfc' created.</strong>" should appear.</p><p>The output shows that the generator created this file for you:</p><ul><li><code>/controllers/Articles.cfc.cfc</code> : The controller file itself</li></ul><p>Let's open up the controller file, <code>/controllers/Articles.cfc</code>. You'll see the <strong>Scaffold</strong> plugin generated a lot of code. It created these actions for us: <code>index</code>, <code>show</code>, <code>new</code>, <code>edit</code>, <code>create</code>, <code>update</code>, and <code>delete</code>.</p><p>Any additional code we add to the controller must go <em>between</em> the beginning and ending <code>cfcomponent</code> instructions, outside any <code>cffunction</code> instructions.</p><p>We have a working controller for CRUD (create, read, update, and delete) but we didn't learn anything so let's comment out everything between the the beginning and ending <code>cfcomponent</code> instructions. We can review this generated code later if you want.</p><h3 id="DefiningtheIndexAction">Defining the Index Action</h3><p>The first action we want to talk about is the "index". This is what the app will send back when a user requests <code>http://wheels.local/index.cfm/Articles/</code> - following the RESTful conventions, this should be a list of the articles. So when the router sees this request come in, it tries to call the <code>index</code> action inside <code>Articles</code> controller. It goes to the <code>index</code> action which gets all our articles:</p><p><pre lang="cfm"><br/><code><br/><cffunction name="index"><br/> &lt;cfset articles = model("Article").findAll() /&gt;<br/></cffunction><br/></code><br/></pre></p><h4 id="PassingActionvariablestoViews">Passing Action variables to Views</h4><p>What scope is <code>articles</code>? Usually in a <code>cfc</code> we will <code>var</code> scope variables to stop data issues. The <code>var</code> instruction marks the variable as a "local variable". We want the list of articles to be accessible from both the controller and the view we're about to create so in order for <code>articles</code> to be visible in both places it has to be in the variable scope. If we had named it <code>var articles</code>, the local variable would only be available within the <code>index</code> action of the controller.</p><p>Let's load <code>http://wheels.local/</code>. You'll notice our updated default route is mapping the code to the <code>index</code> action of the <code>Articles</code> controller but we are getting ann error since the view doesn't exist.</p><p><pre lang="cfm"><br/>Wheels.ViewNotFound<br/>Could not find the view page for the index action in the Articles controller.</p><p>Suggested action</p><p>Create a file named index.cfm in the views/articles directory (create the directory as well if it doesn't already exist).<br/></pre></p><h3 id="CreatingtheIndexView">Creating the Index View</h3><p>The error message is pretty helpful. It tells us Wheels is looking for a template in <code>/views/Articles/</code> but it can't find one named <code>index.cfm</code>. Wheels has <strong>assumed</strong> our <code>index</code> action in the controller should have a corresponding <code>index.cfm</code> view template in the views folder. We didn't have to put any code in the controller to tell it what view we wanted, Wheels figures it out.</p><p>Let's create that view template now. In the left pane of your Eclipse window, expand the <code>JSBloggers</code> project so you can see <code>views</code>, then expand <code>views</code>. Right-click on the <code>views</code> folder, select <code>New</code> then <code>Folder</code> and, in the popup, name the folder <code>Articles</code>. Next repeat the process, but select <code>File</code> and, in the popup, name the file <code>index.cfm</code></p><p>Now you're looking at a blank file. Enter in this view template code which is a mix of HTML and what are called CFML tags:</p><p><pre lang="cfm"><br/><code><br/><h1>Listing articles</h1></p><p><ul><br/> <cfoutput query="articles"><br/>  <li><br/>  <b>#articles.title#</b><br/><br/>  </li><br/> </cfoutput><br/></ul><br/></code><br/></pre></p><p>CFML is a templating language that allows us to mix CFML into our HTML. There are only a few things to know about CFML:</p><ul><li>An CFML clause starts with <code>&lt;cf..&gt;</code> and ends with <code>&lt;/cf..&gt;</code></li><li>If the clause started with <code>&lt;!---</code> and ends with <code>---&gt;</code>, the result of the code in between will be commented out (not ran)</li><li>If the clause started with <code>&lt;cfoutput&gt;</code> and ends with <code>&lt;/cfoutput&gt;</code>, the result of the CFML code will be output in place of the instructions</li></ul><p>Save the file and refresh your web browser. You should see a listing of the articles you created in the Examples. We've got the start of a web application!</p></body></html>