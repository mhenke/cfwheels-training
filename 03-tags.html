<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h2 id="I3Tagging">I3: Tagging </h2><p>In this iteration we'll add the ability to tag articles for organization and navigation. Tagging is similar to some blogs having a "Posted Under" feature. For example, if I wrote a blog post about our training, I might tag it as "Wheels", "Training", and "ColdFusion".</p><p>First we need to think more about what a tag is and how it'll relate to the Article model. If you're not familiar with tags, they're commonly used in blogs to assign the article to one or more categories. For instance, if I write an article about a feature in ColdFusion on Wheels, I might want it tagged with all of these categories: ColdFusion, Wheels, programming, and features. That way if one of my readers is looking for more articles about one of those topics they can click on the tag and see a list of my articles with that tag.</p><h3 id="UnderstandingtheRelationship">Understanding the Relationship</h3><p>What is a tag? We need to figure that out before we can create the model. First, a tag must have a relationship to an article so they can be connected. A single tag, like "ColdFusion" for instance, should be able to relate to <strong>many</strong> articles. On the other side of the relationship, the article might have multiple tags (like "ColdFusion", "Wheels", and "programming" as above) - so it's also a <strong>many</strong> relationship. Articles and tags have a <strong>many-to-many</strong> relationship.</p><p>Many-to-many relationships are tricky because we're using an SQL database. If an Article "has many" tags, then we would put the foreign key <code>articleid</code> inside the <code>tags</code> table - so then a Tag would "belong to" an Article. But a tag can connect to <strong>many</strong> articles, not just one. We can't model this relationship with just the <code>articles</code> and <code>tags</code> tables.</p><p>When we start thinking about the database modeling, there are a few ways to achieve this setup. One way is to create a "join table" that just tracks which tags are connected to which articles. Traditionally this table would be named <code>articlestags</code> and Rails would express the relationships by saying the Article model <code>hasAndBelongsToMany</code> Tags, while the Tag model <code>hasAndBelongsToMany</code> Articles but Wheels doesn't have this relationship yet.</p><p>Even if Wheels did have <code>hasAndBelongsToMany</code>, most of the time this isn't the best way to really model the relationship. The connection between the two models usually has value of its own, so we should promote it to a real model. For our purposes, we'll introduce a model named "Tagging" which is the connection between Articles and Tags. The relationships will setup like this:</p><ul><li>An Article <code>hasMany</code> Taggings</li><li>A Tag <code>hasMany</code> Taggings</li><li>A Tagging <code>belongsTo</code> an Article and <code>belongsTo</code> a Tag</li></ul><h3 id="MakingModels">Making Models</h3><p>With those relationships in mind, let's design the new models:</p><ul><li>Tag<ul><li><code>name</code> A string</li></ul></li><li>Tagging<ul><li><code>tagid</code> Integer holding the foreign key of the related Tag</li><li><code>articleid</code> Integer holding the foreign key of the related Article</li></ul></li></ul><p>Note there are no changes necessary to Article because the foreign key is stored in the Tagging model. So now lets generate these two models with the DBMigrations plugin:</p><p>The tags migration should look like this:</p><p><pre lang="cfm"><br/><code><br/><cfcomponent extends="plugins.dbmigrate.Migration" hint="creates tags tables"><br/> <cffunction name="up" ><br/>  <cfscript ><br/>  t = createTable('tags');<br/>  t = t.string('name');<br/>  t.timestamps();<br/>  t.create();<br/>  </cfscript ><br/> </cffunction ><br/> <cffunction name="down" ><br/>  <cfscript ><br/>  dropTable('tags');<br/>  </cfscript ><br/> </cffunction ><br/></cfcomponent ><br/></code><br/></pre></p><p>The taggings migration should look like this:</p><p><pre lang="cfm"><br/><code><br/><cfcomponent extends="plugins.dbmigrate.Migration" hint="creates taggings table"><br/> <cffunction name="up"><br/>  <cfscript><br/>  t = createTable('taggings');<br/>  t.integer('tagid');<br/>  t.integer('articleid');<br/>  t.create();<br/>  </cfscript><br/> </cffunction><br/> <cffunction name="down"><br/>  <cfscript><br/>  dropTable('taggings');<br/>  </cfscript><br/> </cffunction><br/></cfcomponent><br/></code><br/></pre></p><p>Now run both migrations. Currently DBMigrations plugin doesn't have a command for composite keys, so we will have to run this sql command seperately.</p><p><pre lang="sql"><br/><code><br/>ALTER TABLE jsbloggers.taggings ADD PRIMARY KEY (tagid,articleid);<br/></code><br/></pre></p><h3 id="ExpressingRelationships">Expressing Relationships</h3><p>Now that we created our tables we will need to create our models and tell Wheels about the relationships between them. For each of the files below, create in if not already then add these lines:</p><p>In <code>/models/Article.cfc</code></p><p><pre lang="cfm"><br/><code><br/>&lt;cfset hasMany("taggings") /&gt;<br/></code><br/></pre></p><p>Then in <code>/models/Tagging.cfc</code></p><p><pre lang="cfm"><br/><code><br/>&lt;cfset belongsTo("article") /&gt;<br/>&lt;cfset belongsTo("tag") /&gt;<br/></code><br/></pre></p><p>In <code>/models/Tag.cfc</code></p><p><pre lang="cfm"><br/><code><br/>&lt;cfset hasMany("taggings") /&gt;<br/></code><br/></pre></p><p>Now we can get the many-to-many association that we set up above. Here is how we will include the related tables from the tagging:</p><p><pre lang="cfm"><br/><code><br/>&lt;cfset data = model("tagging").findAll(include="article,tag",where="articleid=3") /&gt;<br/></code><br/></pre></p><p>After Wheels had been around for awhile, developers were finding this kind of relationship very common. In practical usage, if I had an object named <code>article</code> and I wanted to find its Tags, I'd have to run code like this:</p><p><pre lang="cfm"><br/><code><br/> &lt;cfset article = model("article").findByKey(key=3,include="taggings") /&gt;<br/> <cfdump var="#article.taggings#"><br/> <cfabort><br/></code><br/></pre></p><p>That's a pain since we don't have <code>tags</code> yet. The solution was to augment the relationship with "shortcut". We'll update our relationship now to the Article and Tag classes:</p><p>In <code>/models/article.cfc</code></p><p><pre lang="cfm"><br/><code><br/>&lt;cfset hasMany(name="taggings",shortcut="tags") /&gt;<br/></code><br/></pre></p><p>In <code>/models/tag.cfc</code></p><p><pre lang="cfm"><br/><code><br/>&lt;cfset hasMany(name="taggings",shortcut="articles") /&gt;<br/></code><br/></pre></p><p>Now we can get the many-to-many association that we set up above. How we will include the related tables from the tagging is still the same <code>&lt;cfset article = model("article").findByKey(key=3,include="taggings") /&gt;</code>.</p><p>Now if we have an object like <code>article</code> we can just ask for <code>article.tags()</code> or, conversely, if we have an object named <code>tag</code> we can ask for <code>tag.articles()</code>.</p><p>Lets create an example to test our relationship with the "shortcut":</p><p><pre lang="cfm"><br/><code><br/><cffunction name="six"><br/> &lt;cfset article = model("article").findByKey(key=3,include="taggings") /&gt;<br/> <cfdump var="#article.tags()#"></p>&lt;cfset tag = model("tag").findByKey(key=1,include="taggings") /&gt;
 <cfdump var="#tag.articles()#">
 <cfabort>
</cffunction>
</code>
</pre><p>You should see in the articles with their tags in the first dump and tags with their articles.</p><h3 id="AnInterfaceforTaggingArticles">An Interface for Tagging Articles</h3><p>The first interface we're interested in is within the article itself. When I write an article, I want to have a text box where I can enter a new tag. When I save the article, my app should associate my article with the tags with the tag, creating them if necessary.</p><p>Adding the text field will take place in the file <code>/views/articles/_form.cfm</code>. Add this code underneath the body text area like this:</p><p><pre lang="cfm"><br/><code><br/><h3>Tag this post under:</h3><br/>#textFieldTag(name='newTag', label='New Tag')#<br/></code><br/></pre></p><p>This is the first time we used <code>textFieldTag</code>, it builds and returns a string containing a text field form control based on the supplied name. An Article doesn't have a property named <code>newTag</code> - we made it up. In order for us to add a new tag, we need to add a method to the <code>article.cfc</code> file like this:</p><p><pre lang="cfm"><br/><code><br/><cffunction name="newTag"><br/> &lt;cfif len(trim(params.newTag))&gt;<br/>  &lt;cfset Tag = model("Tag").findOne(tagid=Tag.id,articleid=article.id)/&gt;</p> &lt;cfif not isObject(Tag)&gt;
   &lt;cfset Tag = model("Tag").create(name=params.newTag)/&gt;
  </cfif> &lt;cfset Tagging = model("Tagging").create(tagid=Tag.id,articleid=article.id) /&gt;
 </cfif>
</cffunction>
</code>
</pre><p>Your form should now show up and there's a text box at the bottom named "New Tag". Enter content for a new article and in the tag enter <code>ColdFusion</code>. Click SAVE and you'll get a successful message.</p><h3 id="NotSoFast">Not So Fast</h3><p>Did it really work? It's hard to tell. Let's jump into the Examples and have a look. Replace the key with the article, you added the tag to.</p><p><pre lang="cfm"><br/><code><br/><cffunction name="seven"><br/>   &lt;cfset a = model("article").findByKey(key=3,include="taggings") /&gt;<br/>   <cfdump var="#a.tags()#" /><br/>   <cfabort><br/> </cffunction><br/></code><br/></pre></p><p>I bet the Examples Seven reported that <code>a.tags</code> had <code>0</code> tags - an empty query. So we didn't generate an error, but we didn't create any tags either.</p><p>We will need to call our <code>newTag</code> method within our <code>create</code> and <code>update</code> actions by adding <code>&lt;cfset newTag()/&gt;</code>. </p><p><pre lang="cfm"><br/><code><br/><cffunction name="create"><br/> &lt;cfset article = model("article").create(params.article)/&gt;</p>&lt;cfset newTag()/&gt;&lt;cfset flashInsert(message="Article '#article.title#' was created.")/&gt;
 &lt;cfset redirectTo(action="index")&gt;
</cffunction><p><cffunction name="update"><br/> &lt;cfset article = model("Article").findByKey(params.article.id)/&gt;<br/> &lt;cfset article.update(params.article)/&gt;</p>&lt;cfset newTag()/&gt;&lt;cfset redirectTo(action="index")/&gt;
</cffunction>
</code>
</pre><p>Now try adding the tag again and verify it is present in Examples Seven. And you'll see the Tag is associated with the Article.</p><h3 id="AddingTagstoourDisplay">Adding Tags to our Display</h3><p>According to our work in the Examples, articles can now have tags, but we haven't done anything to display them in the article pages. Let's start with <code>/views/articles/show.cfm</code>. Right below the line that displays the <code>article.title</code>, add this line:</p><p><pre lang="cfm"><br/><code><br/><h3>Tags</h3><br/> &lt;cfif article.hasTaggings() EQ "YES"&gt;<br/>  <cfloop query="tags"><br/>   #linkTo(text=tags.name, controller="tags", action="show", key=tags.id)#<br><br/>  </cfloop><br/> <cfelse><br/>  None<br/> </cfif><br/></code><br/></pre></p><p>These lines should loop and output through all the <code>tags</code> for the article.</p><p>Refresh your view and...BOOM:</p><p><pre lang="cfm"><br/>Attribute validation error for tag cfloop.</p><p>The value of the attribute query, which is currently tags, is invalid.<br/></pre></p><p>The <code>show</code> page is trying to use <code>tags</code>, but the action doesn't know anything about our Tags variable. We need to create the <code>tags</code> vaiable in the <code>show</code> action of the <code>/controllers/Article.cfc</code>. Open up <code>/controllers/Article.cfc</code> and add this code <code>&lt;cfset tags = article.tags(order="name")/&gt;</code> inside the <code>show</code> method.</p><p>Now refresh your view and you should see your tags showing up on the individual article pages.</p><h3 id="ShowingTagsintheNewAndEdit">Showing Tags in the New And Edit</h3><p>We need an easy way to display already existing tags and allow selecting or deselecting them. Wheels has a <code>hasManyCheckBox</code> form helper. It is used as a shortcut to output the proper form elements for an association. First we need to add <code>&lt;cfset tags = model("Tag").findAll(order="name")/&gt;</code> to our <code>new</code> and <code>edit</code> actions in <code>/controllers/Article.cfc</code>. Then we can use the <code>hasManyCheckBox</code> in <code>views/articles/_form.cfm</code> under the <code>&lt;h3&gt;Tag this post under:&lt;/h3&gt;</code>.</p><p><pre lang="cfm"><br/><code><br/><h3>Tag this post under:</h3><br/><cfloop query="tags"><br/> #hasManyCheckBox(<br/>  label=tags.name,<br/>  objectName="article",<br/>  association="taggings",<br/>  keys="#tags.id#,#article.key()#"<br/> )#<br/></cfloop><br/></code><br/></pre></p><p>In our <code>new</code> action, we need to mode the exisitn code slightly ending up with this:</p><p><pre lang="cfm"><br/><code><br/><cffunction name="new"><br/> &lt;cfset var newTagging = arrayNew(1)/&gt;<br/> &lt;cfset tag = model("tag").new()/&gt;<br/> &lt;cfset tags = model("Tag").findAll(order="name")/&gt;<br/> &lt;cfset newTagging<sup class="footnote"><a href="#___fn1">1</a></sup> = model("tagging").new()/&gt;<br/> &lt;cfset article = model("article").new(taggings=newTagging)/&gt;<br/></cffunction><br/></code><br/></pre></p><p>The first line creates an array in our local scope. We did this since we don't need the variable in the views. The next new line <code>&lt;cfset newTagging[1] = model("tagging").new()/&gt;</code> uses that variable and creates a new Tagging in it. Then when creating our new article object we pass in the <code>newTaggings</code> array as taggings. Let's dump the <code>article</code> and abort the process when creating a new article to see this object. Be sure to remove the dump and abort after examining the output.</p><p>Create an Article with some tags and then edit it. You should see all the existing tags and any already associated with the article when editing.</p><h3 id="AvoidingRepeatedTags">Avoiding Repeated Tags</h3><p>Lets Tag an acticle with "Glee Club". Then lets update the Article and you'll see "Glee Club" checked. What happens if we type in "Glee Club" again in the "New Tag" input.  What is happenning? How would we solve this?</p><p>It prevents duplicates and allows you to remove tags from the edit form. Test it out and make sure things are working!</p><h3 id="ListingArticlesbyTag">Listing Articles by Tag</h3><p>The links for our tags are showing up, but if you click on them you'll get our old friend, the "Wheels.ViewNotFound". Createyour <code>/controllers/Tags.cfc</code> and add a <code>show</code> method like this:</p><p><pre lang="cfm"><br/><code><br/><cfcomponent extends="Controller" output="false"></p><p><cffunction name="show"><br/> &lt;cfset tags = model("tag").findByKey(key=params.key,include="taggings") /&gt;<br/> &lt;cfset articles = tags.articles() /&gt;<br/></cffunction></p><p></cfcomponent><br/></code><br/></pre></p><p>Then create a file <code>/views/tags/show.cfm</code> like this:</p><p><pre lang="cfm"><br/><code><br/><cfoutput><br/><h1>Articles Tagged with #tags.name#</h1><br/><ul><br/>	<cfloop query="articles" ><br/>		<li>#linkTo(text=articles.title, controller="articles", action="show", key=articles.articleid)#<br></li><br/>	</cfloop><br/></ul><br/></cfoutput><br/></code><br/></pre></p><p>Refresh your view and you should see a list of articles with that tag. Keep in mind that there might be some abnormalities from articles we tagged. For any article with issues, try going to it's <code>edit</code> screen, saving it, and things should be fixed up. If you wanted to clear out all taggings you could do <code>&lt;cfset model("Tagging").deleteAll()/&gt;</code> from your Examples.</p><h3 id="ListingAllTags">Listing All Tags</h3><p>We've built the <code>show</code> action, but the reader should also be able to browse the tags available at <code>http://wheels.local/tags/</code>. I think you can do this on your own. Create an <code>index</code> action in your <code>tags.cfc</code> and an <code>index.cfm</code> in the corresponding views folder. Look at your <code>Articles.cfc</code> and Article <code>index.cfm</code> if you need some clues.</p><p>If that's easy, try creating a <code>delete</code> method in your <code>tags.cfc</code> and adding a delete link to the tag list. If you do this, change the association in your <code>tag.cfc</code> so that it says <code>hasMany :taggings, :dependent =&gt; :delete</code>. That'll prevent orphaned Tagging objects from hanging around.</p><p>With that, a long Iteration 3 is complete!</p></body></html>