h1. I1: Form-Based Workflow

We've created an articles page, but that isn't a viable long-term solution. The users of our app will expect to add content through a web interface. In this iteration we'll create an HTML form to submit the article, then all the backend processing to get it into the database.

h3. Creating the NEW Action and View

Previously we setup the @<cfset addRoute(name="home", pattern="", controller="Articles", action="index")>@ route in @/config/routes.cfm@, and that told CFWheels that we were going to follow the RESTful conventions for this model named Article. Following this convention, the URL for creating a new article would be @http://wheels.local/index.cfm/articles/new@. Enter that into your browser and see what comes up.

<pre>
<code>
Wheels.ViewNotFound
Could not find the view page for the new action in the Articles controller.

Suggested action

Create a file named new.cfm in the views/articles directory (create the directory as well if it doesn't already exist).
</code>
</pre>

This is an error message we've seen before. The router went looking for an action named @new@ inside the @Articles.cfc@ and didn't find it.

So first let's create that action. Open @/controllers/Articles.cfc@ and add this method structure, making sure it's _inside_ the @cfcomponent@ instruction, but _outside_ the existing @index@ method:

<pre>
<code>
<cffunction name="new">

</cffunction>
</code>
</pre>

Create a new file @/views/Articles/new.cfm@ with these contents:

<pre>
<code>
<h1>Create a New Article</h1>
</code>
</pre>

Refresh your browser and you should just see the heading "Create a New Article".

h3. Writing a Form

It's not very impressive so far -- we need to add a form to the @new.cfm@ so the user can enter in the article title and body. Because we're following the RESTful conventions, CFWheels can take care of many of the details. Inside that @cfm@ file, enter this code below your header:

<pre>
<code>
<cfoutput>
 #errorMessagesFor("article")#
 #startFormTag(action="create")#
  #textField(objectName='article', property='title', label='Title')#
  #textArea(objectName='article', property='body', label='Body')#
  #submitTag()#
 #endFormTag()#
</cfoutput>
</code>
</pre>

What is all that?  Let's look at it piece by piece:

* @startFormTag@ is a CFWheels helper instruction which takes an action parameter, in this case @create@, The first line basically says "Make an openning form tag with the name of the action included in the URL" .
* The @textField@ helper creates a single-line text field control
** The @objectName@ parameter which says for this input use the object named @article@ to build the form control
** The @property@ parameter create the name of the property to use in the form control
** The @lable@ parameter creates an HTML label for the form control, this is good usability practice and will have some other benefits for us later
* The @textArea@ helper creates a text area field form control 
* The @submitTag@ helper creates a submit button labeled "Save changes"
* The @endFormTag@ helper creates the ending form tag

Refresh your browser and you'll see this:

<pre>
Wheels.ObjectNotFound
Wheels tried to find the model object article for the form helper, but it does not exist.

Error location

Line 3 in views\articles\new.cfm

2: <cfoutput>
3:  #errorMessagesFor("article")#
4:  #startFormTag(action="create")#
5:   #textField(objectName='article', property='title', label='Title')#
6:   #textArea(objectName='article', property='body', label='Body')#
7:   #submitTag()#
</pre>

What's it trying to tell us. In our @new.cfm@ on line #3 there was an error about "Wheels.ObjectNotFound". Somewhere in line #4 we're working with an object that doesn't exist.

And since there's only one object in line #3, it makes it pretty obvious -- the problem is that we started talking about a thing named @article@ without ever creating that thing. CFWheels uses some of the _reflection_ techniques that we talked about earlier in order to setup the form. Remember in the @Examples.cfc@ when we called @Article.new@ to create a new object?  CFWheels wants to do the same thing, but we need to create the blank object for it.

Go into your @Articles.cfc@, and _inside_ the @new@ method, add this line:

<pre>
<code>
 <cfset article = model("Article").new()>
</code>
</pre>

Then refresh your browser and your form should come up. Enter in a title, some body text, and click "Save changes".

h3. The CREATE Action

You're old friend pops up again...

<pre>
Wheels.ViewNotFound
Could not find the view page for the create action in the Articles controller.

Suggested action

Create a file named create.cfm in the views/articles directory (create the directory as well if it doesn't already exist).
</pre>

When we loaded the form we accessed the @new@ action, but when that form is submitted to the application, following the REST convention, it goes to a @create@ action. We need to create that action. Inside your @Articles.cfc@ add this method (again, _inside_ the @cfcomponent@ instuction, but _outside_ the other methods):

<pre>
<code>
 <cffunction name="create">
  <cfset article = model("Article").new(params.article)>
  <cfset article.save() />
  <cfset redirectTo(action="index")>
 </cffunction>
</code>
</pre>

This method says...

* Create an object named @article@ and send in the parameter @params.article@
* CFWheels makes the form data available inside the variable named @params@. If we're to look at @params@ as a data structure, it'd be a structure with only a key called @article@. The value of that pair is another structure with keys @title@ and @body@. The values for those keys are the data we entered into the text boxes on the form. So when @Article.new@ is called and the structure @params.article@ is passed in, the @new@ method looks for the value with key @title@ and puts that into the Article's @title@ attribute. Then it looks for the value for key @body@ and puts that into the article's @body@ attribute.
* The line @<cfset article.save() />@ saves the object to the database, just like we did in the examples.
* Finally, the @redirectTo@ tells CFWheels that we don't want to render a view for this action. Once the previous steps are done, we want to bounce to the list of all articles. This @renderPage(action="index")@ resolve to http://wheels.local/index.cfm/articles/.

Go back in your browser so you get to the form with the sample data you entered and click "Save changes". You should then bounce to the full articles list with your new article added.

h3. Adding Navigation to the Index

Right now our article list is very plain and we end up typing in a bunch of URLs by hand. Let's add some links. Open your @/views/articles/index.cfm@ and...

* Add this code at the very bottom:

<pre>
<code>
 <cfoutput>
  <p>#linkTo(text="Create a New Article", action="new")#</p>
 </cfoutput>
</code>
</pre>

It uses the CFWheels @linkTo@ helper, tells it we want a link with the text "Create a New Article" that points to the address @new@ (which the router handles for us)
* Find where, in the middle of the view, we output just the @title@. Change it so it says @linkTo(text=title, action='show', key=id)@. This creates a link with the text of the articles title which points to a page where we'll show just that article.

Refresh your browser and you should now see a list of the article titles that are linked somewhere and a link at the bottom to "Create a New Article". Test that this create link takes you to the new article form. Then go back to the article list and click one of the article titles.

h3. Creating the SHOW Action

Tired of this error message yet?  Go to your @Articles.cfc@ and add a method like this:

<pre>
<code>
 <cffunction name="show">
	
 </cffunction>
</code>
</pre>

Let's pause here before creating the view template.

Look at the URL: @http://wheels.local/index.cfm/articles/show/1@. When we added the @linkTo@ in the index and pointed it to the @show@ for this @article@, the router created this URL. Following the RESTful convention, this URL goes to a SHOW method which would display the Article with ID number @1@. Your URL might have a different number depending on which article title you clicked in the index.

So what do we want to do when the user clicks an article title?  Find the article, then display a page with it's title and body. We'll use the number on the end of the URL to find the article in the database. The router will send us this number in the variable @params.key@. Inside the @show@ method that we just created, add this line:

<pre>
 <cfset article = model("Article").findByKey(params.key)>
</pre>

Now create the file @/views/articles/show.cfm@ and add this code:

<pre>
<code>
<cfoutput>
 <h2>#article.title#</h2>
 <p>#article.body#</p>
 #linkTo(text="<< Back to Articles List", action="index")#
</cfoutput>
</code>
</pre>

Refresh your browser and your article should show up along with a link back to the index.

h3. But You Never Make Mistakes!

We can create articles and we can display them, but when we eventually deliver this to less perfect people than us, they're going to make mistakes. Right now there's no way to edit an article once it's been created. There's also no way to remove an article. Let's add those functions.

Look at your @index.cfm@ and change the whole @<li>@ segment so it looks like this:

<pre>
    <li>
      <b><%= linkTo article.title, article_path(article) %></b><br/>
      <i>Actions:
      <%= linkTo "edit", edit_article_path(article) %>,
      <%= linkTo "remove", article, :method => :delete,
                   :confirm => "Remove the article '#{article.title}'?" %>      
      </i>
    </li>
</pre>

<pre>
<code>
<li>
 <b>#linkTo(text=title, action="show")#</b><br/>
 <i>Actions:
 #linkTo(text='edit', action='edit', key=id)#,
 #linkTo(text='remove', action='delete', key=id, confirm="Remove the article '#title#'?")# 
 </i> 
</i>
</code>
</pre>

The first link we added, for edit, is pretty similar to what we've done before -- creating a link with the text "edit" pointing to the address @edit@, which is defined by the router, and editing the key named @id@.

The second one is a little more complex. So this link will have the text "remove", will point to the @delete@. We've also added a @confirm@ parameter. If a link has a @confirm@, then CFWheels will generate some Javascript which will popup a box when the link is clicked that contains the text in the @confirm@. Here we're setting the message to check that the user wants to remove the article and including the article's title in the message.

Refresh your browser and you should see "edit" and "remove" links for each article. Click the EDIT link for your first article.

h3. Creating an Edit Action & View

The router is expecting to find an action in @Articles.cfc@ named @edit@, so let's add this:

<pre>
<cffunction name="edit">
 <cfset article = model("Article").findByKey(params.key)>
</cffunction>
</pre>

All the @edit@ action is really going to do is find the article to be edited, then display the editing form. If you refresh after adding that @edit@ action you'll see the template missing error. Create a file @/views/articles/edit.cfm@ but *hold on before you type anything*. Below is what the edit form should look like:

<pre>
<code>
<h1>Edit an Article</h1>
<cfoutput>
 #errorMessagesFor("article")#
 #startFormTag(action="create")#
  #textField(objectName='article', property='title', label='Title')#
  #textArea(objectName='article', property='body', label='Body')#
  #submitTag(value="Update")#
 #endFormTag()#
</cfoutput>
<code>
</pre>

In the ColdFusion and CFWheels communities there is a mantra of "Don't Repeat Yourself" -- but that's exactly what I've done here. This view is basically the same as the @new.cfm@ -- the only changes are the H1 and the submit button now has a value parameter. It will display in the button form control. We can abstract this form into a single file called a _partial_, then reference this partial from both @new.cfm@ and @edit.cfm@.

Create a file @/views/articles/_form.cfm@ and, yes, it has to have the underscore at the beginning of the filename. Go into your @/views/articles/new.cfm@ and CUT all the text from and including the @cfoutput@ line all the way to it's ending @cfoutput@. The only thing left will be your H1 line. Then add the following code at the bottom of that view:

<pre>
<code>
 <cfoutput>#includePartial("form")#</cfoutput>
</code>
</pre>

Now go back to the @_form.cfm@ and paste the form code. Change the text on the @submit@ button to say "Save" so it makes sense both when creating a new article and editing and existing one.

Then look at your @edit.cfm@ file, write an H1 header saying "Edit an Article", then use the same code to render the partial named @form@.

Go back to your articles list and try creating a new article -- it should work just fine. Try editing an article and you should see the form with the existing article's data -- it works OK until you click SAVE.

The router is looking for an action named @update@. Just like the @new@ action sends it's form data to the @create@ action, the @edit@ action sends it's form data to the @update@ action. In fact, within our @Articles.cfc@, the @update@ method will look very similar to @create@

<pre>
<code>
<cffunction name="update">
 <cfset article = model("Article").findByKey(params.key) />
 <cfset article.update(params.article) />
 <cfset redirectTo(action="index") />
</cffunction>
</code>
</pre>

The only new bit here is the @update@ method. This method works very similar to when we called the @new@ method and passed in the structure of form data. When we call @update@ on the @article@ object and pass in the data from the form, it changes the values in the object to match the values submitted with the form. Then we save the object to the database and redirect to the articles list.

Now try editing and saving some of your articles.

h3. Creating a delete Action

Next, click the REMOVE link for one article and hit OK. You can see that the router is expecting there to be a @delete@ action. Go into @Articles.cfc@ and add a delete method like this:

<pre>
<code>
<cffunction name="delete">
 <cfset article = model("Article").findByKey(params.key) />
 <cfset article.delete() />
 <cfset redirectTo(action="index") />
</cffunction>
</code>
</pre>

Here we're doing a @findByKey@ based on @params.key@ like we did in the @show@ action. We call that object's @delete@ method, then redirect back to the articles list.

Try it out in your browser.

h3. Adding a Flash

It would be nice, though, if we gave the user some kind of status message about the operation that took place. When we create an article the message might say "Article 'the-article-title' was created", or "Article 'the-article-title' was removed" for the remove action. We can accomplish this with a special object called the @flash@.

CFWheels creates the object named @flash@, so we don't need to do anything to set it up. We can start by integrating it into our @index.cfm@ by adding this line at the very top:

<pre>
<code>
<div class="flash"><p><cfoutput>#flash("message")#</cfoutput></p></div>
</code>
</pre>

This just outputs the value stored in the @flash@ object with the key @message@. If you refresh your articles list you won't see anything because we haven't stored a message in there yet. Look at @Articles.cfc@ and add this line right after the @save!@ line in your @create@ method:

<pre>
<code>
<cfset flashInsert(message="Article '#article.title#' was created.") />
</code>
</pre>

Then go to your articles list, create another sample article, and when you click create you should see the flash message at the top of your view.

Here's something cool about how CFWheels handles the @flash@ -- hit your browser's REFRESH button while looking at the articles list. See how the flash disappears?  Once you display the message in a flash CFWheels clears it out. That's why it's perfect for status messages like this.

Similarly, add a flash message into your @delete@ method and confirm that it shows up when an article is removed. Then add one to your @update@ method that'll display when an article is edited.

And, finally, you're done with I1!