h1. I2: Adding Comments

Most blogs allow the reader to interact with the content by posting comments. Let's add some simple comment functionality.

h3. Designing the Comment Model

First, we need to brainstorm what a comment _is_...what kinds of data does it have...

* It's attached to an article
* It has an author name
* It usually has an author email address
* It usually has an optional URL
* It has a body

With that understanding, let's create a Comment model. Switch over to Eclipse and right click on the models folder, then select New --> File and enter "Comment.cfc" for File name. The file will be created and automatically open, then you can add this code to it:

<pre>
<code>
<cfcomponent extends="Model" output="false">
 <cffunction name="init">
 
 </cffunction>
</cfcomponent>
</code>
</pre>

Pretty simple, huh?

h3. Setting up the Migration

Open the DBMigrate plugin and fill it out with the following and click "create":

* Select template:  Create table
* Migration description: creates comments table

Open the file that the generator created, @/db/migrate/some-timestamp_creates_comments_table.cfc@. Inside the @self.up@ you need to add one line for each of the pieces of data we just brainstormed. It'll start off with these...

<pre>
t.integer('articleid');
t.string('authorname');
</pre>

Then keep adding lines that create strings named @authoremail@, @authorurl@, and a text field named @body@.

Once that's complete, go to the DBMigrate plugin and run the migration by clicking go.

h3. Relationships

The power of SQL databases is the ability to express relationships between elements of data. We can join together the information about an order with the information about a customer. Or in our case here, join together an article (in the articles table) with its comments (in the comments table). We do this by using foreign keys.

Foreign keys are a way of marking one-to-one and one-to-many relationships. An article might have zero, five, or one hundred comments. But a comment only belongs to one article. These objects have a one-to-many relationship -- one article connects to many comments.

Part of the big deal with CFWheels is that it makes working with these relationships very easy. When we created the migration for comments we started with an @integer@ field named @articleid@. The CFWheels convention is that, for a one-to-many relationship, the objects on the "many" end should have a foreign key referencing the "one" object. And that foreign key should be titled with the name of the "one" object, then "id". So in this case one article has many comments, so each comment has a field named @articleid@ which tracks which article they belong to. Similarly, a store's customer might have many orders, so each order would have a @customerid@ specifying which customer they belong to.

Following this convention will get us a lot of functionality "for free."  Open your @/models/comment.cfc@ and add the middle line so it looks like this:

<pre>
<code>
<cfcomponent extends="Model" output="false">

 <cffunction name="init">
  <cfset belongsTo("article")>
 </cffunction>

</cfcomponent>
</code>
</pre>

A comment relates to a single article, it "belongs to" an article. We then want to declare the other side of the relationship inside @/models/article.cfc@ like this:

<pre>
<code>
 <cffunction name="init">
  <cfset hasMany("comments")>
 </cffunction>
</code>
</pre>

How an article "has many" comments, and a comment "belongs to" an article. We have explained to CFWheels that these objects have a one-to-many relationship.

h3. Testing in Examples

Let's use the @/controllers/Examples.cfc@ to test how this relationship works in code. Open the @Examples.cfc@ file and paste in the following instructions and observe the output at at "http://wheels.local/index.cfm/Examples/three":http://wheels.local/index.cfm/Examples/three :

<pre>
<code>
<cffunction name="three">
 <cfset a = model("article").findByKey(key=3,include="comments") />
 <cfdump var="#a.comments#" />
 <cfdump var="#model("comment").new()#" />
 <cfdump var="#a.newComment()#" />
 <cfabort>
</cffunction>
</code>
</pre>

When you called the @comments@ method on object @a@, it gave you back a blank array because that article doesn't have any comments. When you executed @model("comment").new()@ it gave you back a blank Comment object. But, if you look closely, when you did @a.newComment()@ the comment object you got back wasn't quite blank -- it has the @articleid@ field already filled in with the ID number of article @a@.

Try creating a few comments for that article like this:

<pre>
<code>
<cffunction name="four">
 <cfset a = model("article").findByKey(key=3,include="comments") />
 
 <cfset c = a.newComment() />
 <cfset c.authorname = "Daffy Duck" />
 <cfset c.authorurl = "http://daffyduck.com" />
 <cfset c.body = "I think this article is thhh-thhh-thupid!" />
 <cfset c.save() />

 <cfset d = a.createComment(authorname = "Chewbacca", body = "RAWR!") />
 <cfabort>
</cffunction>
</code>
</pre>

For the first comment, @c@, I used a series of commands like we've done before. For the second comment, @d@, I used the @create@ method. When you use @new@ it doesn't go to the database until you call @save@. With @create@ you usually pass in the attributes then the object is created, those attributes set, and the object saved to the database all in one step.

Now that you've created a few comments, try executing @a.comments@ again. 

<pre>
<code>
<cffunction name="five">
 <cfset a = model("article").findByKey(key=3,include="comments") />
 <cfdump var="#a.comments#" />
 <cfabort>
</cffunction>
</code>
</pre>

Did your comments all show up? Great. Now we need to integrate them into the article display.

h3. Displaying Comments for an Article

We want to display any comments underneath their parent article. Because we've setup the relationships between those models, this is very easy. Open @/views/articles/show.cfm@ and add the following lines right before the link to the articles list:

<pre>
<code>
<h3>Comments</h3>
<cfoutput>#includePartial(article.comments)#</cfoutput>
</code>
</pre>

This says that we want to render a partial named "comment" and that we want to do it once for each element in the collection @article.comments@. We saw in the Examples that when we call the @comments@ method on an article we'll get back an array of it's associated comment objects. So this render line will pass each element of that array one at a time into the partial named "comment". Now we need to create the file @/views/articles/_comment.cfm@ and add this code:

<pre>
<code>
<cfoutput>
<div class="comment">
  <h4>Comment by #arguments.comment.authorname#</h4>
  <p>#arguments.comment.body#</p>
</div>
</cfoutput>
</code>
</pre>

With that in place, try clicking on your articles and find the one where you created the comments. Did they show up?  What happens when an article doesn't have any comments?

h3. Web-Based Comment Creation

Good start, but our users (hopefully) can't get into the Examples code to create their comments. We'll need to create a web interface. We'll go through some of the same steps that we did when creating the web interface for creating articles.

Let's start with the form. The comment form should be embedded into the article's @show@ template. So let's add this code right above the "Back to Articles List" in the articles @show.cfm@

<pre>
<%= render :partial => 'comment_form' %>
</pre>

Obviously this is expecting a file @/views/articles/_comment_form.cfm@, so create that and add this content for now:

<pre>
<h3>Post a Comment</h3>
<p>(Comment form will go here)</p>
</pre>

Look at an article in your browser to make sure that partial is showing up. Then we can start figuring out the details of the form.

Ok, now look at your @Articles.cfc@ in the @new@ method. Remember how we had to create a blank Article object so CFWheels could figure out which fields an article has?  We need to do the same thing before we create a form for the comment. But when we view the article and display the comment form we're not running the article's @new@ method, we're running the @show@ method. So we'll need to create a blank Comment object inside that @show@ method like this:

<pre>
@comment = @article.comments.new
</pre>

This is just like we did it in the Examples. Now we can create a form inside our @_comment_form.cfm@ partial like this:

<pre>
<h3>Post a Comment</h3>

<% form_for @comment do |f| %>
  <%= f.hidden_field :articleid, :value => @article.id %>
  <p>
    <%= f.label :author_name %><br/>
    <%= f.text_field :author_name %>
  </p>
  <p>
    <%= f.label :author_email %><br/>
    <%= f.text_field :author_email %>
  </p>
  <p>
    <%= f.label :author_url %><br/>
    <%= f.text_field :author_url %>
  </p>
  <p>
    <%= f.label :body %><br/>
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit 'Submit' %>
  </p>
<% end %>
</pre>

The only new thing here is the hidden field helper. This hidden field will hold the ID of the article to help when creating the comment object.

Save then refresh in your web browser and...well...you'll get an error like this:

<pre>
NoMethodError in Articles#show
Showing app/views/articles/_comment_form.cfm where line #3 raised:
undefined method `comments_path' for #<ActionView::Base:0x10446e510>
</pre>

The @form_for@ helper is trying to build the form so that it submits to @comments_path@, but we haven't told the router anything about Comments yet. Open @/config/routes.rb@ and add this line at the top:

<pre>
map.resources :comments
</pre>

Then refresh your browser and your form should show up. Try filling out the comments form and click SUBMIT -- you'll get an error about @uninitialized constant CommentsController@.

h3. Creating a Comments Controller

Just like we needed an @Articles.cfc@ to manipulate our Articles, we'll need a @comments_controller.rb@. Switch over to your terminal to generate it with this line:

<pre>
ColdFusion script/generate controller comments index create delete
</pre>

What's up with those extra parameters?  Anything after the name of the controller (in this case "comments") will cause CFWheels to create stubs for methods with those names. Now open your @/app/controllers/comments_controller.rb@ and you'll see it has the three method stubs already.

The one we're interested in first is @create@. You can cheat by looking at the @create@ method in your @Articles.cfc@. For your @comments_controller.rb@, everything should be the same just replace article with comment. Then the redirect is a little different, use this:

<pre>
redirect_to article_path(@comment.article)
</pre>

Test out your form to create another comment now -- and it should work!

h3. Cleaning Up

We've got some decent comment functionality, but there are a few things we should add and tweak.

h4. Comments Count

Let's make it so where the view template has the "Comments" header it displays how many comments there are, like "Comments (3)". Open up your article's @show.cfm@ and change the comments header so it looks like this:

<pre>
<h3>Comments (<%= @article.comments.size %>)</h3>
</pre>

h4. Form Labels

The comments form looks a little silly with "Author Name" and "Author URL" and such. It should probably say "Your Name" and "Your URL (optional)", right?  To change the text that the label helper prints out, you just pass in the desired text as a second parameter, like this:

<pre>
<%= f.label :author_name, "Your Name"  %>
</pre>

Change your @_comment_form.cfm@ so it prints out "Your Name", "Your Email Address", "Your URL (optional)", and "Your Comment".

h4. Add Timestamp to the Comment Display

We should add something about when the comment was posted. CFWheels has a really neat helper named @distance_of_time_in_words@ which takes two dates and creates a text description of their difference like "32 minutes later", "3 months later", and so on. You can use it in your @_comment.cfm@ partial like this:

<pre>
<p>Posted <%= distance_of_time_in_words(comment.article.created_at, comment.created_at) %> later</p>
</pre>

With that, you're done with I2!